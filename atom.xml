<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Here. There.</title>
  
  <subtitle>Love ice cream. Love sunshine. Love life. Love the world. Love myself. Love you.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://godbasin.github.io/"/>
  <updated>2022-03-06T03:27:42.738Z</updated>
  <id>https://godbasin.github.io/</id>
  
  <author>
    <name>被删</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端性能优化方案归纳</title>
    <link href="https://godbasin.github.io/2022/03/06/front-end-performance-optimization/"/>
    <id>https://godbasin.github.io/2022/03/06/front-end-performance-optimization/</id>
    <published>2022-03-06T03:24:13.000Z</published>
    <updated>2022-03-06T03:27:42.738Z</updated>
    
    <content type="html"><![CDATA[<p>对于前端开发来说，性能优化老生常谈了。不管是日常工作中，还是涉及到晋级答辩，性能都是频繁被我们提及的一个话题。</p><p>性能优化不是一劳永逸的解决方案，项目在发展过程，代码不断地迭代和变更。我们在某个阶段优化过的代码，过段时间性能又会慢慢下降，这也是前端开发常把性能挂在嘴边的原因。</p><a id="more"></a><p>当页面加载时间过长、交互操作不流畅时，会给用户带来很糟糕的体验。越是使用时间越长的产品，用户对体验的要求越高，如果出现卡顿或是加载缓慢，最坏的情况下会导致用户的流失。</p><p>对于性能优化，其实解决方案也比较常见和通用了，但是基本上也只有指导思想，实施起来还得具体项目具体分析。</p><h1 id="常见的性能优化方案"><a href="#常见的性能优化方案" class="headerlink" title="常见的性能优化方案"></a>常见的性能优化方案</h1><p>对于前端应用来说，网络耗时、页面加载耗时、脚本执行耗时、渲染耗时等耗时情况会影响用户的等待时长，而 CPU 占用、内存占用、本地缓存占用等则可能会导致页面卡顿甚至卡死。</p><p>因此，性能优化可以分别从<strong>耗时和资源占用</strong>两方面来解决，我个人也比较喜欢将其称为“时间”和“空间”两个维度。</p><h2 id="时间角度优化：减少耗时"><a href="#时间角度优化：减少耗时" class="headerlink" title="时间角度优化：减少耗时"></a>时间角度优化：减少耗时</h2><p>我们知道浏览器在页面加载过程中，会进行以下的步骤：</p><ul><li>网络请求相关（发起 HTTP 请求从服务端获取页面资源，包括 HTML/CSS/JS/图片资源等）</li><li>浏览器解析 HTML 和渲染页面</li><li>加载 Javascript 代码时会暂停页面渲染（包括解析到外部资源，会发起 HTTP 请求获取并加载）</li></ul><p>在浏览器的首次加载和渲染完成之后，不代表用户就可以马上交互和操作。根据业务代码加载过程，页面还会分别进入页面开始渲染、渲染完成、用户可交互等阶段。除此之外，页面交互过程中，会根据业务逻辑进行逻辑运算、页面更新。</p><blockquote><p>题外话：为什么我们常常说要理解原理呢？性能优化便是个很好的例子，如果你不知道这个过程具体发生了什么，就很难找到地方下手去进行优化。</p></blockquote><p>根据这个过程，我们可以从四个方面进行耗时优化：</p><ol><li>网络请求优化。</li><li>首屏加载优化。</li><li>渲染过程优化。</li><li>计算/逻辑运行提速。</li></ol><p>在前端性能优化实践中，网络请求优化和首屏加载优化方案使用频率最高，因为不管项目规模如何、各个模块和逻辑是否复杂，这两个方向的耗时优化方案都是比较通用的。相比之下，对于页面内容较多、交互逻辑/运算逻辑复杂的项目，才需要针对性地进行渲染过程优化和计算/逻辑运行提速。</p><p>一起来看看~</p><h3 id="1-网络请求优化"><a href="#1-网络请求优化" class="headerlink" title="1. 网络请求优化"></a>1. 网络请求优化</h3><p>网络请求优化的目标在于减少网络资源的请求和加载耗时，如果考虑 HTTP 请求过程，显然我们可以从几个角度来进行优化：</p><ol><li>请求链路：DNS 查询、部署 CDN 节点、缓存等。</li><li>数据大小：代码大小、图片资源等。</li></ol><p>对于请求链路，核心的方案常常包括使用缓存，比如 DNS 缓存、CDN 缓存、HTTP 缓存、后台缓存等等，前端的话还可以考虑使用 Service Worker、PWA 等技术。使用缓存并非万能药，很多使用由于缓存的存在，我们在功能更新修复的时候还需要考虑缓存的情况。除此之外，还可以考虑使用 HTTP/2、HTTP/3 等提升资源请求速度，以及对多个请求进行合并，减少通信次数；对请求进行域名拆分，提升并发请求数量。</p><p>数据大小则主要考对请求资源进行合理的拆分（CSS、Javascript 脚本、图片/音频/视频等）和压缩，减少请求资源的体积，比如使用 Tree-shaking、代码分割、移除用不上的依赖项等。</p><p>在请求资源返回后，浏览器会进行解析和加载，这个过程会影响页面的可见时间，通过对首屏加载的优化，可有效地提升用户体验。</p><h3 id="2-首屏加载优化"><a href="#2-首屏加载优化" class="headerlink" title="2. 首屏加载优化"></a>2. 首屏加载优化</h3><p>首屏加载优化核心点在于两部分：</p><ol><li>将页面内容尽快地展示给用户，减少页面白屏时间。</li><li>将用户可操作的时间尽量提前，避免用户无法操作的卡顿体验。</li></ol><p>减少白屏时间除了我们常说的首屏加载耗时优化，还可以考虑使用一些过渡的动画，让用户感知到页面正在顺利加载，从而避免用户对于白屏页面或是静止页面产生烦躁和困惑。除了技术侧的优化，很多时候产品策略的调整，给用户带来的体验优化效果不低于技术手段优化，因此我们也需要重视。</p><p>整体的优化思路包括：尽可能提前页面可见，以及将用户可交互的时间提前。一般来说，我们需要尽可能地降低首屏需要的代码量和执行耗时，可以通过以下方式进行：</p><ul><li>对页面的内容进行分片/分屏加载</li><li>仅加载需要的资源，通过异步或是懒加载的方式加载剩余资源</li><li>使用骨架屏进行预渲染</li><li>使用差异化服务，比如读写分离，对于不同场景按需加载所需要的模块</li><li>使用服务端直出渲染，减少页面二次请求和渲染的耗时</li></ul><p>有些时候，我们的页面也需要在客户端进行展示，此时可充分利用客户端的优势：</p><ul><li>配合客户端进行资源预请求和预加载，比如使用预热 Web 容器</li><li>配合客户端将资源和数据进行离线，可用于下一次页面的快速渲染</li><li>使用秒看技术，通过生成预览图片的方式提前将页面内容提供给用户</li></ul><p>除了首屏渲染以外，用户在浏览器页面过程中，也会触发页面的二次运算和渲染，此时需要进行渲染过程的优化。</p><h3 id="3-渲染过程优化"><a href="#3-渲染过程优化" class="headerlink" title="3. 渲染过程优化"></a>3. 渲染过程优化</h3><p>渲染过程的优化要怎么定义呢？我们可以将其理解为首屏加载完成后，用户的操作交互触发的二次渲染。</p><p>主要思路是减少用户的操作等待时间，以及通过将页面渲染帧率保持在 60FPS 左右，提升页面交互和渲染的流畅度。包括但不限于以下方案：</p><ul><li>使用资源预加载，提升空闲时间的资源利用率</li><li>减少/合并 DOM 操作，减少浏览器渲染过程中的计算耗时</li><li>使用离屏渲染，在页面不可见的地方提前进行渲染（比如 Canvas 离屏渲染）</li><li>通过合理使用浏览器 GPU 能力，提升浏览器渲染效率（比如使用 css transform 代替 Canvas 缩放绘制）</li></ul><p>以上这些，是对常见的 Web 页面渲染优化方案。对于运算逻辑复杂、计算量较大的业务逻辑，我们还需要进行计算/逻辑运行的提速。</p><h3 id="4-计算-逻辑运行提速"><a href="#4-计算-逻辑运行提速" class="headerlink" title="4. 计算/逻辑运行提速"></a>4. 计算/逻辑运行提速</h3><p>计算/逻辑运行速度优化的主要思路是“拆大为小、多路并行”，方式包括但不限于：</p><ul><li>通过将 Javscript 大任务进行拆解，结合异步任务的管理，避免出现长时间计算导致页面卡顿的情况</li><li>将耗时长且非关键逻辑的计算拆离，比如使用 Web Worker</li><li>通过使用运行效率更高的方式，减少计算耗时，比如使用 Webassembly</li><li>通过将计算过程提前，减少计算等待时长，比如使用 AOT 技术</li><li>通过使用更优的算法或是存储结构，提升计算效率，比如 VSCode 使用红黑树优化文本缓冲区的计算</li><li>通过将计算结果缓存的方式，减少运算次数</li></ul><p>以上便是<strong>时间</strong>维度的性能优化思路，还有<strong>空间</strong>维度的资源优化情况。</p><h2 id="空间角度优化：降低资源占用"><a href="#空间角度优化：降低资源占用" class="headerlink" title="空间角度优化：降低资源占用"></a>空间角度优化：降低资源占用</h2><p>提到性能优化，大多数我们都在针对页面加载耗时进行优化，对资源占用的优化会更少，因为资源占用常常会直接受到用户设备性能和适应场景的影响，大多数情况下优化效果会比耗时优化局限，因此这里也只能说一些大概的思路。</p><p>资源占用常见的优化方式包括：</p><ul><li>合理使用缓存，不滥用用户的缓存资源（比如浏览器缓存、IndexDB），及时进行缓存清理</li><li>避免存在内存泄露，比如尽量避免全局变量的使用、及时解除引用等</li><li>避免复杂/异常的递归调用，导致调用栈的溢出</li><li>通过使用数据结构享元的方式，减少对象的创建，从而减少内存占用</li></ul><p>说到底，我们在做性能优化的时候，其实很多情况下会依赖时间换空间、空间换时间等方式。性能优化没有银弹，只能根据自己项目的实际情况做出取舍，选择相对合适的一种方案去进行优化。</p><p>对于页面耗时和资源占用的性能优化分析，大部分情况都可以使用 Chrome 开发者工具进行针对性的分析和优化。</p><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>实际上，除了遇到问题的时候进行优化，更优的方案是在工作流中搭建一个监控性能指标的步骤，每次变更发布前都跑一遍，发现性能下降之后进行及时的告警，推动开发者解决。对于这块，之前我也有简单描述过，可以参考<a href="https://godbasin.github.io/front-end-playground/front-end-basic/deep-learning/front-end-performance-analyze.html">《补齐 Web 前端性能分析的工具盲点》</a>一文。</p><p>对于性能优化，其实本文只整理和归纳了一些常见的思路，至于实际上在项目中要怎么处理和使用，等有空的时候我再来跟大家讲一下~~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于前端开发来说，性能优化老生常谈了。不管是日常工作中，还是涉及到晋级答辩，性能都是频繁被我们提及的一个话题。&lt;/p&gt;
&lt;p&gt;性能优化不是一劳永逸的解决方案，项目在发展过程，代码不断地迭代和变更。我们在某个阶段优化过的代码，过段时间性能又会慢慢下降，这也是前端开发常把性能挂在嘴边的原因。&lt;/p&gt;
    
    </summary>
    
      <category term="前端解决方案" scheme="https://godbasin.github.io/categories/%E5%89%8D%E7%AB%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
      <category term="性能优化" scheme="https://godbasin.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>前端这几年--答辩晋级这件事</title>
    <link href="https://godbasin.github.io/2022/02/27/about-updating/"/>
    <id>https://godbasin.github.io/2022/02/27/about-updating/</id>
    <published>2022-02-27T07:31:34.000Z</published>
    <updated>2022-02-27T07:39:55.933Z</updated>
    
    <content type="html"><![CDATA[<p>最近又是答辩季，程序员最讨厌写的 PPT 又到了不得不写的时候了。之前也有在帮一些小伙伴做准备，所以顺便给大家分享一些晋级答辩的思考和技巧吧～</p><a id="more"></a><p>关于答辩晋级这个内容，最开始我是直接做的视频放在 B 站分享，参考<a href="https://www.bilibili.com/video/BV1tu411X7qn/" target="_blank" rel="noopener">《程序员日志–晋级答辩这件事》</a>。</p><blockquote><p>关于做视频和写文章，感觉自己从最初的只会写文章，到现在已经慢慢也会做一些视频了。视频的表达和文章相差很远，我自己的感受是，对于需要反复阅读、技术深度的内容，还是更适合用文章来记录。而视频更适合写一些需要录屏和讲解的模式，加上 PPT 本身的结构化，更容易去给大家梳理清楚逻辑架构，但是很多细节就很难讲清楚了。</p></blockquote><h2 id="如何对待晋级答辩这件事"><a href="#如何对待晋级答辩这件事" class="headerlink" title="如何对待晋级答辩这件事"></a>如何对待晋级答辩这件事</h2><p>对于很多大公司的程序员来说，晋级答辩关乎着是否可以升职加薪，而答辩成功与否常常会对个人的工作态度和心态造成较大的影响。</p><p>我个人的看法是：<strong>认真对待它，但不要过分依赖它。</strong></p><p>这句话怎么理解呢？如果你仔细观察身边其他同事，大多数会分成两类：</p><ol><li>平时工作只是完成工作本身，不希望受到答辩影响，但是到答辩的时候却临时抱佛脚。</li><li>过分看重答辩，在平日工作里就抢一些方便答辩的活，如果没有的话甚至自己造各种轮子，而不在乎这些轮子是否合适。</li></ol><p>以上两种态度都可以改善，我们可以在平时就认真地把手上的每件事做好，而到了答辩的时候也要认真地对待，但是不要因为答辩这件事影响了自己原本该有的工作态度和对待项目质量的要求。</p><p>或许有些人会疑惑，造不合适的轮子，为什么答辩能通过呢？</p><p>其实答辩这件事，本身也有认知偏差和主观因素。由于陈述内容是由答辩人自身提供的，所以很多时候都会只把好的一面呈现出来，而使用的技术栈或是造的一些轮子给原有项目造成的影响，或是带来的技术债务，或许就只有项目内的其他成员知道了。</p><p>除此之外，因为答辩是由评委来评分的，因此主观上如果评委比较感兴趣的内容，会更容易通过；而如果是评委熟悉的领域，则会被问到很深入和核心的问题，这样的可能性会更高。</p><p>所以，更多的时候，我认为答辩是否能通过是很需要运气的，包括我自己通过的几次答辩，都有不小的运气成分在里面。这也是为什么，我想跟大家说不要过分依赖晋级答辩，因为如果你过分看重和孤注一掷，那么不管成功与否，都会对你以后的工作心态产生影响。</p><p>那么，正如我视频里所说的，关于答辩这件事，你需要知道：</p><ol><li>答辩是由 70% 的努力 + 30% 的运气组成的。</li><li>答辩考核的除了工作内容，还有工作方式和答辩技巧。</li><li>答辩是结果，不是目的。</li></ol><p>既然我们还是需要认真对待答辩这件事，该怎么去进行准备呢？</p><h2 id="如何准备答辩"><a href="#如何准备答辩" class="headerlink" title="如何准备答辩"></a>如何准备答辩</h2><p>其实，答辩本身也属于项目复盘的一种方式，所以其实我们在平时工作里，就可以用更优的工作方式和节奏，去把事情做好。</p><h3 id="平时工作要做好"><a href="#平时工作要做好" class="headerlink" title="平时工作要做好"></a>平时工作要做好</h3><p>如果我们在平时工作中，就有认真地思考每一个项目，更加结构化地去关注项目中的每个阶段的话，相比答辩本身能给我们自身带来更多的成长。</p><p>我们会常常看到，需要开发在工作的时候基本上是线性的工作方式，即：遇到问题 -&gt; 解决问题 -&gt; 结束。</p><p>实际上，我们可以在每个问题上思考更多：</p><p><strong>(1) 做一件事的目的，需要贯穿全过程。</strong></p><p>很多时候，我们在遇到一个问题的时候，马上就开始找解决方案了。其实我们可以先暂停，去思考下这个问题是如何产生的，我们需要解决的到底是什么程度的问题，做这件事的目的是什么。</p><p>而在问题处理完成之后，同样需要回顾当初这个问题的目的是否已经达成，是否还遗留有待解决的问题，等等。</p><p><strong>(2) 拓展自身的思维，更加结构化地去做事。</strong></p><p>比如，在寻找解决方案的时候，当我们找到一个解决方向的时候，可以先不着急去马上解决，而是需要考虑是否还有其他解决方案？当前方案是否最优？解决方案是否存在局限？是否有更多的探索可能性？</p><p>充分做好前期调研之后，再对多个方案进行对比，结合自身项目的情况，找到最适合用于项目中的一个解决方案。</p><p><strong>(3) 将一件事情的价值最大化。</strong></p><p>很多时候，我们处理完一个问题，这个事情就结束了。对于团队来说，这样的方式其实效率很低，因为不同的团队成员很可能会遇到相同的问题，如果每个人都花费这些时间去获得差不多的结论，那么团队的成长会很慢。</p><p>我们可以选择将每次处理问题的过程和解决方案进行总结沉淀，然后分享给其他人。这样，团队内就可以共享每个人努力的成果，这对于团队来说成长是很快的，而对团队中的每个人来说亦是如此。</p><p>而沉淀和总结本身，也可以促进个人的成长。在开发的职业生涯是，是否具备这样的能力和认识，是十分关键的。</p><h3 id="答辩-项目内容结构"><a href="#答辩-项目内容结构" class="headerlink" title="答辩/项目内容结构"></a>答辩/项目内容结构</h3><p>对于答辩本身，我们首先要知道：要能让评委认可你的能力，首先得高效地让评委理解项目中的各个过程。</p><p>因此，大多数时候我们的答辩内容都可以分为以下结构：</p><ol><li>项目背景/问题描述。讲清楚做这个项目的背景情况和目的，这是最起码的铺垫。</li><li>难点/挑战点。如果评委感受不到项目中的难点，那么这个项目又怎么证明你的能力呢？</li><li>方案调研/方案对比。工作方式中，做好前期足够的调研和准备，认真对比得到的解决方案，才可以说是合适的方案。</li><li>（解决过程）。过程大多数时候无关紧要，但是如果同样存在难点，也可以一并描述。</li><li>项目结果（最终效果/数据论证）。如果有足够的证据佐证，那么这个项目的成果便是无可置疑的。</li><li>展望：遗留问题/后续计划/产生更多价值。从点到面发散这个项目，是否可以做更多？</li><li>个人影响力。</li></ol><p>这里就不过多描述了，其实如果你有认真思考以上的点，基本就可以说是有认真对待一个项目，同时自己也能从中获得足够多的成长和沉淀了。</p><p>除去答辩本身，以上的这些内容其实在我们日常的工作里，同样需要进行思考和去完成的。也就是说，这样的结构点，并不只是答辩所需，而是需要贯彻到我们工作的每个项目/每个遇到的问题里，这样才能更好地脚踏实地，同时也不需要再为答辩专门做更多的处理了。</p><h3 id="答辩技巧"><a href="#答辩技巧" class="headerlink" title="答辩技巧"></a>答辩技巧</h3><p>如果说我们在平时就已经把工作结构化地做好了，是否意味着答辩就能一定顺利呢？</p><p>除了内容本身需要踏实以外，我们还需要掌握一定的答辩技巧，比如:</p><ul><li>PPT 思路清晰，可以参考上述答辩内容结构来进行梳理</li><li>适当使用动画，突出重点。动画的用处在于让对方注意力聚焦在自己讲的内容上，所以要避免过分浮夸的动画</li><li>陈述足够熟练/脱稿，自己或是找同事多练几遍</li><li>思考项目中的不足/可能提问的问题，准备到如何回答</li></ul><p>以上等等。</p><p>如果你有时间，可以来看看这个视频（<a href="https://www.bilibili.com/video/BV1tu411X7qn/" target="_blank" rel="noopener">也可以直接去 B 站看原视频哦</a>）：</p><div style="position: relative; padding: 30% 45%;"><br><br><iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://player.bilibili.com/player.html?aid=509223755&bvid=BV1tu411X7qn&cid=512396881&page=1&high_quality=1" frameborder="no" scrolling="no"><br><br></iframe><br><br></div><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>在工作中，我看到过不少由于晋级失败、拿了差考核而开始怀疑自我的小伙伴。我想说的是，工作只是人生的一部分，并不代表着全部，也不可以因为工作的不顺利而否定或是认定自己的一生。</p><p>实际上，失败才是大多数人一生的主旋律，我们要尽早学会如何与失望和意外相处，要接受不完美的自己，学会认可自己。世界上有无数的人，失败或是成功，但是只有一个自己，要学会爱上这个自己。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近又是答辩季，程序员最讨厌写的 PPT 又到了不得不写的时候了。之前也有在帮一些小伙伴做准备，所以顺便给大家分享一些晋级答辩的思考和技巧吧～&lt;/p&gt;
    
    </summary>
    
      <category term="工作这杯茶" scheme="https://godbasin.github.io/categories/%E5%B7%A5%E4%BD%9C%E8%BF%99%E6%9D%AF%E8%8C%B6/"/>
    
    
      <category term="心态" scheme="https://godbasin.github.io/tags/%E5%BF%83%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>我所理解的前端工程化</title>
    <link href="https://godbasin.github.io/2022/02/07/front-end-engineering/"/>
    <id>https://godbasin.github.io/2022/02/07/front-end-engineering/</id>
    <published>2022-02-07T07:22:23.000Z</published>
    <updated>2022-02-07T07:33:20.409Z</updated>
    
    <content type="html"><![CDATA[<p>前端工程化这个词出现的频率越来越高，一直没有明确的定义，有些人认为是模块化和自动化的工具，比如 Webpack/Gulp、脚手架、组件化等，但工具只是一些辅助手段，并不能作为工程化来理解。</p><a id="more"></a><p>个人认为，前端工程化致力于提升工程的开发效率、协作效率、项目质量，贯穿项目设计、开发、测试、上线、维护的整个过程。</p><p>那么，工程化要解决的问题，便是我们在这些过程中遇到的一些问题了。</p><h1 id="前端项目开发常见问题"><a href="#前端项目开发常见问题" class="headerlink" title="前端项目开发常见问题"></a>前端项目开发常见问题</h1><p>相信大家的日常工作中也能感受到，相比于从 0 到 1 搭建项目，我们的大部分工作都是在维护项目，基于现有的项目上进行迭代和开发。正所谓铁打的营盘流水的兵，每个项目都会经历很多开发的参与、协作和交接，在这个过程中常常会遇到很多的问题，这些问题可以分为两类：<strong>系统质量的下降</strong>，以及<strong>开发效率的下降</strong>。</p><h2 id="系统质量"><a href="#系统质量" class="headerlink" title="系统质量"></a>系统质量</h2><blockquote><p>“没有 BUG 的系统是不存在的。”  – 《被删的开发手册》</p></blockquote><h3 id="系统质量的下降"><a href="#系统质量的下降" class="headerlink" title="系统质量的下降"></a>系统质量的下降</h3><p>BUG 的出现有很多的可能性，比如需求设计不严谨、代码实现的逻辑有漏洞、不在预期之内的异常逻辑分支，等等。除了方案设计和思考的经验不足，BUG 很多时候也会因为对项目的不熟悉、对系统的理解不深入引入，这意味着以下的过程会导致 BUG 的增加：</p><ol><li>项目频繁地调整（新增或者更换）开发人员，由于不熟悉项目，每个新加入的小伙伴都可能会埋下新的 BUG。</li><li>系统功能新增和迭代、不断壮大，各个模块间的耦合增加、复杂度增加。如果没法掌握系统的所有细节，很可能牵一发而动全身，产生自己认知以外的 BUG。</li></ol><p>对于处于快速迭代、不断拓展阶段的项目来说，不管是人员的变动、还是项目的拓展都是无法避免的。除此之外，为了降低系统的复杂度，当项目发展到一定阶段的时候，会对系统进行局部或是整体的架构调整，比如模块的拆分、各个模块间的依赖解耦、引入新的状态管理工具、重复逻辑进行抽象和封装等等。</p><p>新技术的引入会缓解系统复杂度带来的稳定性问题，但同时也可能会引入新的问题，比如：</p><ul><li>部分功能无法与新技术兼容，成为历史遗留问题</li><li>较大范围的架构调整影响面很广，可能埋下难以发现的 BUG</li></ul><p>可见，一个项目不断发展的过程中，都会面临系统质量下降的问题。</p><h3 id="提升系统质量"><a href="#提升系统质量" class="headerlink" title="提升系统质量"></a>提升系统质量</h3><p>为了提升系统质量，我们需要对项目进行合理的架构调整，提升系统的可读性、可维护性、可测试行、稳定性，从而提升系统发布的稳定性。</p><p>我们在进行架构设计时，需要根据项目的预期和现状来设计，保留拓展性的同时，避免过度设计。因此，随着项目不断发展，原有的架构设计可能不再适合，此时我们需要进行优化和调整，比如：</p><ul><li>引入新的技术和工具</li><li>团队成员增加，沟通成本和对规范的理解出现差异</li><li>项目代码量和文件数的增加</li><li>进行自动化测试能力的覆盖</li><li>搭建完善的监控和告警体系</li></ul><p>在这个过程中，我们可能分别引入了新的代码构建、代码规范和自动化测试工具，搭建了新的监控系统、发布系统、流程控制等，这些都属于前端工程化的一部分。</p><p>但是对于开发来说，开发流程变得繁琐，意味着工作内容更复杂，同时还增加了很多新工具和系统的熟悉成本。那么，我们还可以通过优化项目的研发和发布流程，来提升项目的开发效率。</p><h2 id="开发效率"><a href="#开发效率" class="headerlink" title="开发效率"></a>开发效率</h2><blockquote><p>“今天又要加班了，因为今天的代码还没开始写。” – 《被删的开发手册》</p></blockquote><h3 id="开发效率的下降"><a href="#开发效率的下降" class="headerlink" title="开发效率的下降"></a>开发效率的下降</h3><p>系统上线之后，开发的工作内容重心，会从功能开发逐渐转向其它内容。除了新功能的评审和设计以外，还会包括：</p><ul><li>用户反馈问题跟进和定位</li><li>线上 BUG 修复和紧急发布</li><li>处理系统的监控告警，排查异常问题</li><li>新功能灰度发布过程，自测、产品验证功能、提测、修复 BUG、灰度发布等各个流程都需要人工操作和主动关注</li><li>为了保证系统质量，需要完善自动化测试能力，包括单元测试、UI 测试、集成测试等</li><li>项目成员的调整，需要进行工作的交接、指导对方的工作内容等</li></ul><p>开发的工作内容变得复杂，需要关注的事情也更多，对于各个系统（监控告警系统、日志系统、测试系统、发布系统等）也都需要熟悉成本和操作成本。在各个工作内容之间切换，也常常容易出现步骤的遗漏，导致一些流程上的问题，比如：</p><ol><li>系统灰度到一半，处理其它事情忘了全量。</li><li>系统发布之后，去处理紧急 BUG、忘记看监控，直到收到大量的用户反馈。</li><li>线上紧急 BUG 修复了，急着发布忘了进行自动化测试。</li></ol><p>随着项目规模变大，系统的复杂度也随之上升，上面所提到的工作量也都会增加，开发效率会肉眼可见地受到影响。以前一天工作量的功能开发，如今需要三天时间才能完成，因为每天只有三分之一的时间（甚至更少）可以用来开发新功能。</p><p>在这个项目阶段，开发每天的杂事太多、效率太低、浑浑噩噩不知道都做了些什么，团队面临着项目复杂度上升、系统质量不稳定、技术债务越来越多、团队工作效率下降等问题。</p><h3 id="提升开发效率"><a href="#提升开发效率" class="headerlink" title="提升开发效率"></a>提升开发效率</h3><p>项目研发和发布流程优化的核心点在于：将一切需要手动操作和关注的内容自动化。</p><p>那么，我们先来梳理下项目开发和发布过程中，到底有多少繁琐的工作可以进行自动化。一般来说，开发在接到产品需求单后，会涉及到分支管理、代码构建、环境部署、测试/验证、问题修复、灰度发布、监控告警、需求单状态扭转等各个流程。</p><p>每一次功能发布，都需要花费很多的精力在各个流程步骤上。我们可以将这些步骤都转为自动化，就可以让开发的精力聚焦在功能的设计和实现上。对于流程自动化，业界比较成熟的解决方案是使用持续集成（continuous integration，简称 CI）和持续部署（continuous deployment，简称 CD）：</p><ul><li>持续集成（CI）：目的是让产品可以快速迭代，同时还能保持高质量</li><li>持续部署（CD）：目的是代码在任何时刻都是可部署、可进入生产阶段</li></ul><p>CI 在项目中的实践，指团队成员频繁（一天多次）地提交代码到主干分支，每次提交后会自动触发自动化验证的任务集合，以便尽可能地提前发现问题；CD 在项目中的实践，指代码通过评审以后，可自动化、可控、多批次地部署到生产环境，CD 的前提是能自动化完成测试、构建、部署等步骤。</p><p>CI/CD 在项目中的落地，很多时候会表现为流水线的开发模式：通过建立完整的 CI/CD 流水线，涵盖整个研发流程，可有效地提高效率。一般来说，我们可以搭建这样的 CI/CD 流水线：</p><ul><li>需求单分配：分配并自动拉取相应 Git 分支</li><li>代码提交：代码规范检查 + 自动化测试 + 部署测试环境 + 根据需求单配置通知相应的产品和测试</li><li>产品验证/功能测试：BUG 单自动关联需求单和分支 + 验证完成后，根据需求单通知开发侧</li><li>BUG 修复：代码规范检查 + 自动化测试 + 部署测试环境 + 根据分支 BUG 单和需求单通知测试 + 验证完成后，根据需求单通知开发侧</li><li>代码合入主干：向团队成员发起代码 Review + Review 通过后代码合入主干</li><li>日常发布：定时器发起发布流程 + 预发布环境部署 + 进行自动化测试 + 测试通过后进入灰度过程</li><li>灰度发布：根据配置比例进行灰度 + 灰度过程中自动化进行监控 + 可选择性进入快速回滚流程</li><li>全量发布：自动扭转需求单状态，并将版本进行归档（Git Tag）</li></ul><p>通过将以上流程自动化，可以节省开发的很多人工操作时间、提升开发效率的同时，也避免了人工操作容易出现的遗漏和失误。将自动化流水线与通知/告警机器人、工作群、需求单系统、BUG 系统、代码管理系统、发布系统、监控系统结合，实现全研发和发布流程的自动化，开发可从各种杂事中释放，专注于功能开发的实现。</p><p>越是大规模、系统建设完备的团队，开发流程中消耗在多人协作和各个系统的操作中的精力越多，搭建 CI/CD 后更能体会到自动化流程带来的便利。</p><p>当然，搭建 CI/CD 的过程中，也需要投入不少的人力精力。因此，很多时候我们可以考虑性价比，从对研发效能影响最大的痛点开始进行建设，可以最快速和有效地提升团队的开发效率，让更多的人愿意参与到 CI/CD 的建设中。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><blockquote><p>“能用机器解决的问题，就不要依赖人。” – 《被删的开发手册》</p></blockquote><p>项目维护阶段的最大痛点，其实在于开发无法聚焦自身的工作内容，常常需要在各种系统中进行操作和切换，从而带来开发效率的下降，以及注意力分散、无法更全面的思考导致了不合理的设计、新的 BUG 引入，而影响了系统的质量。</p><p>前端工程化的出现，正是为了解决系统质量和效率低下的问题。但前端工程化并不只是局限于代码构建和流水线，可以将其理解为解决项目开发过程中遇到的所有问题，目的在于提升系统质量和开发效率。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端工程化这个词出现的频率越来越高，一直没有明确的定义，有些人认为是模块化和自动化的工具，比如 Webpack/Gulp、脚手架、组件化等，但工具只是一些辅助手段，并不能作为工程化来理解。&lt;/p&gt;
    
    </summary>
    
      <category term="前端解决方案" scheme="https://godbasin.github.io/categories/%E5%89%8D%E7%AB%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
      <category term="逻辑实现" scheme="https://godbasin.github.io/tags/%E9%80%BB%E8%BE%91%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>Angular框架解读--Ivy编译器之变更检测</title>
    <link href="https://godbasin.github.io/2022/01/09/angular-design-ivy-6-detect-change/"/>
    <id>https://godbasin.github.io/2022/01/09/angular-design-ivy-6-detect-change/</id>
    <published>2022-01-09T12:01:48.000Z</published>
    <updated>2022-01-09T12:10:04.321Z</updated>
    
    <content type="html"><![CDATA[<p>作为“为大型前端项目”而设计的前端框架，Angular 其实有许多值得参考和学习的设计，本系列主要用于研究这些设计和功能的实现原理。本文围绕 Angular 的核心功能 Ivy 编译器，介绍其中变更检测的过程。</p><a id="more"></a><p>上一篇<a href="https://godbasin.github.io/2021/12/05/angular-design-ivy-5-incremental-dom/">《Angular框架解读–Ivy编译器之增量DOM》</a>中，我介绍了 Ivy 编译器中使用了增量 DOM 的设计。在 Ivy 中，通过编译器将模板编译为<code>template</code>渲染函数，该过程会将对模板的解析编译成增量 DOM 相关的指令。其中，在<code>elementStart()</code>执行时，我们可以看到会通过<code>createElementNode()</code>方法来创建 DOM。</p><p>而增量 DOM 中的变更检测、Diff 和更新 DOM 等能力，都与<code>elementStart()</code>方法紧紧关联着。</p><h2 id="Ivy-中的变更检测"><a href="#Ivy-中的变更检测" class="headerlink" title="Ivy 中的变更检测"></a>Ivy 中的变更检测</h2><h3 id="ngZone-的自动变更检测"><a href="#ngZone-的自动变更检测" class="headerlink" title="ngZone 的自动变更检测"></a>ngZone 的自动变更检测</h3><p>在<a href="https://godbasin.github.io/2021/05/30/angular-design-zone-ngzone/">《Angular框架解读–Zone区域之ngZone》</a>一文中，我们介绍了默认情况下，所有异步操作都在 Angular Zone 内。该逻辑在创建 Angular 应用的时候便已添加，这会自动触发变更检测：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ApplicationRef &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">      <span class="keyword">private</span> _zone: NgZone, <span class="keyword">private</span> _injector: Injector, <span class="keyword">private</span> _exceptionHandler: ErrorHandler,</span></span><br><span class="line"><span class="params">      <span class="keyword">private</span> _componentFactoryResolver: ComponentFactoryResolver,</span></span><br><span class="line"><span class="params">      <span class="keyword">private</span> _initStatus: ApplicationInitStatus</span>) &#123;</span><br><span class="line">    <span class="comment">// Microtask 为空时，触发变更检测</span></span><br><span class="line">    <span class="keyword">this</span>._onMicrotaskEmptySubscription = <span class="keyword">this</span>._zone.onMicrotaskEmpty.subscribe(&#123;</span><br><span class="line">      next: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>._zone.run(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// tick 为变更检测的逻辑，会重新进行 template 的计算和渲染</span></span><br><span class="line">          <span class="keyword">this</span>.tick();</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tick</code>方法中，核心的逻辑是调用了<code>view.detectChanges()</code>来检测更新。该接口来自<code>ChangeDetectorRef</code>，它提供变更检测功能的基类。</p><p>变更检测树收集所有要检查变更的视图，可以使用方法从树中添加和删除视图，启动更改检测，并将视图显式标记为<code>_dirty_</code>，这意味着它们已更改并需要重新渲染。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">abstract</span> <span class="keyword">class</span> ChangeDetectorRef &#123;</span><br><span class="line">  <span class="comment">// 当视图中的输入更改或事件触发时，组件通常被标记为脏（需要重新渲染）</span></span><br><span class="line">  <span class="comment">// 调用此方法以确保即使未发生这些触发器也会检查组件</span></span><br><span class="line">  <span class="keyword">abstract</span> markForCheck(): <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从变更检测树中分离此视图，在重新附加之前不会检查分离的视图</span></span><br><span class="line">  <span class="comment">// 与 detectChanges() 结合使用以实现本地更改检测检查</span></span><br><span class="line">  <span class="keyword">abstract</span> detach(): <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查此视图及其子视图</span></span><br><span class="line">  <span class="comment">// 与 detach() 结合使用以实现本地更改检测检查</span></span><br><span class="line">  <span class="keyword">abstract</span> detectChanges(): <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查更改检测器及其子项，如果检测到任何更改则抛出</span></span><br><span class="line">  <span class="keyword">abstract</span> checkNoChanges(): <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将先前分离的视图重新附加到更改检测树</span></span><br><span class="line">  <span class="comment">// 默认情况下，视图附加到树</span></span><br><span class="line">  <span class="keyword">abstract</span> reattach(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述的<code>ChangeDetectorRef</code>中，变更检测<code>detectChanges()</code>中，核心逻辑调用了<code>refreshView()</code>。</p><h3 id="refreshView-视图更新处理"><a href="#refreshView-视图更新处理" class="headerlink" title="refreshView 视图更新处理"></a>refreshView 视图更新处理</h3><p><code>refreshView()</code>用于在更新模式下处理视图：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">refreshView</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    tView: TView, lView: LView, templateFn: ComponentTemplate&lt;&#123;&#125;&gt;|<span class="literal">null</span>, context: T</span>) </span>&#123;</span><br><span class="line">  ngDevMode &amp;&amp; assertEqual(isCreationMode(lView), <span class="literal">false</span>, <span class="string">'Should be run in update mode'</span>);</span><br><span class="line">  <span class="keyword">const</span> flags = lView[FLAGS];</span><br><span class="line">  enterView(lView);</span><br><span class="line">  <span class="keyword">const</span> isInCheckNoChangesPass = isInCheckNoChangesMode();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    resetPreOrderHookFlags(lView);</span><br><span class="line"></span><br><span class="line">    setBindingIndex(tView.bindingStartIndex);</span><br><span class="line">    <span class="keyword">if</span> (templateFn !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 1. 执行 template 模板函数</span></span><br><span class="line">      executeTemplate(tView, lView, templateFn, RenderFlags.Update, context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 执行预处理钩子，包括 OnInit、OnChanges、DoCheck</span></span><br><span class="line">    <span class="keyword">if</span> (!isInCheckNoChangesPass) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hooksInitPhaseCompleted) &#123;</span><br><span class="line">        executeCheckHooks(lView, preOrderCheckHooks, <span class="literal">null</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        executeInitAndCheckHooks(lView, preOrderHooks, InitPhaseState.OnInitHooksToBeRun, <span class="literal">null</span>);</span><br><span class="line">        incrementInitPhaseFlags(lView, InitPhaseState.OnInitHooksToBeRun);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先将在此 lView 中声明的移植视图标记为需要在其插入点刷新</span></span><br><span class="line">    <span class="comment">// 这是为了避免模板在这个 LView 中定义但它的声明出现在插入组件之后的情况</span></span><br><span class="line">    markTransplantedViewsForRefresh(lView);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历嵌入式视图（通过 ViewContainerRef API 创建的视图）并通过执行关联的模板函数刷新它们</span></span><br><span class="line">    refreshEmbeddedViews(lView);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 在调用内容钩子之前，必须刷新内容查询结果</span></span><br><span class="line">    <span class="keyword">if</span> (tView.contentQueries !== <span class="literal">null</span>) &#123;</span><br><span class="line">      refreshContentQueries(tView, lView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行内容钩子，包括 AfterContentInit, AfterContentChecked</span></span><br><span class="line">    <span class="keyword">if</span> (!isInCheckNoChangesPass) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hooksInitPhaseCompleted) &#123;</span><br><span class="line">        executeCheckHooks(lView, contentCheckHooks);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        executeInitAndCheckHooks(lView, contentHooks, InitPhaseState.AfterContentInitHooksToBeRun);</span><br><span class="line">        incrementInitPhaseFlags(lView, InitPhaseState.AfterContentInitHooksToBeRun);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 设置 host 绑定</span></span><br><span class="line">    processHostBindingOpCodes(tView, lView);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 刷新子组件视图</span></span><br><span class="line">    <span class="keyword">const</span> components = tView.components;</span><br><span class="line">    <span class="keyword">if</span> (components !== <span class="literal">null</span>) &#123;</span><br><span class="line">      refreshChildComponents(lView, components);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新子组件后必须执行视图查询，因为此视图中的模板可以插入子组件中</span></span><br><span class="line">    <span class="comment">// 如果视图查询在子组件刷新之前执行，则模板可能尚未插入</span></span><br><span class="line">    <span class="keyword">const</span> viewQuery = tView.viewQuery;</span><br><span class="line">    <span class="keyword">if</span> (viewQuery !== <span class="literal">null</span>) &#123;</span><br><span class="line">      executeViewQueryFn(RenderFlags.Update, viewQuery, context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行视图钩子，包括 AfterViewInit, AfterViewChecked</span></span><br><span class="line">    <span class="keyword">if</span> (!isInCheckNoChangesPass) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hooksInitPhaseCompleted) &#123;</span><br><span class="line">        executeCheckHooks(lView, viewCheckHooks);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        executeInitAndCheckHooks(lView, viewHooks, InitPhaseState.AfterViewInitHooksToBeRun);</span><br><span class="line">        incrementInitPhaseFlags(lView, InitPhaseState.AfterViewInitHooksToBeRun);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 我们需要确保我们只在成功的 refreshView 上翻转标志</span></span><br><span class="line">    <span class="keyword">if</span> (tView.firstUpdatePass === <span class="literal">true</span>) &#123;</span><br><span class="line">      tView.firstUpdatePass = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在检查无变化模式下运行时不要重置脏状态</span></span><br><span class="line">    <span class="comment">// 例如：在 ngAfterViewInit 钩子中将 OnPush 组件标记为脏组件以刷新 NgClass 绑定应该可以工作</span></span><br><span class="line">    <span class="keyword">if</span> (!isInCheckNoChangesPass) &#123;</span><br><span class="line">      lView[FLAGS] &amp;= ~(LViewFlags.Dirty | LViewFlags.FirstLViewPass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lView[FLAGS] &amp; LViewFlags.RefreshTransplantedView) &#123;</span><br><span class="line">      lView[FLAGS] &amp;= ~LViewFlags.RefreshTransplantedView;</span><br><span class="line">      updateTransplantedViewCount(lView[PARENT] <span class="keyword">as</span> LContainer, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    leaveView();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>refreshView()</code>的处理包括按特定顺序执行的多个步骤：</p><ol><li>在更新模式下，执行<code>template</code>模板函数。</li><li>执行钩子。</li><li>刷新 Query 查询。</li><li>设置 host 绑定。</li><li>刷新子（嵌入式和组件）视图。</li></ol><p>除此之外，在变更检测的最开始执行了<code>enterView()</code>，此时 Angular 会用新的<code>LView</code>交换当前的<code>LView</code>。这样的处理主要出于性能原因，通过将<code>LView</code>存储在模块的顶层，最大限度地减少了要读取的属性数量。</p><p><code>LView</code>用于存储从模板调用指令时处理指令所需的所有信息，在<a href>《Angular框架解读–Ivy编译器的视图数据和依赖解析》</a>中有介绍。</p><p>每个嵌入视图和组件视图都有自己的<code>LView</code>。在处理特定视图时，我们将<code>viewData</code>设置为该<code>LView</code>。当该视图完成处理后，<code>viewData</code>被设置回原始<code>viewData</code>之前的任何内容（父<code>LView</code>）。</p><p>在<code>refreshView()</code>处理中，每当进入新视图时会存储<code>LView</code>以备后用。我们也可以看到当退出视图时，通过执行<code>leaveView()</code>离开当前的<code>LView</code>，恢复原来的状态。</p><p>以上便是变更检测过程中的视图处理逻辑。</p><h3 id="创建与更新视图的处理"><a href="#创建与更新视图的处理" class="headerlink" title="创建与更新视图的处理"></a>创建与更新视图的处理</h3><p>我们可以对比下创建视图的过程，处理视图创建的过程在<code>renderView()</code>中实现。</p><p><code>renderView()</code>用于在创建模式下处理视图，该过程包括按特定顺序执行的多个步骤：</p><ol><li>创建视图查询函数（如果有）。</li><li>在创建模式下，执行<code>template()</code>模板函数。</li><li>更新静态 Query 查询（如果有）。</li><li>创建在给定视图中定义的子组件。</li></ol><p>在上一篇文章中，我们介绍了这样一个组件：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, Input &#125; <span class="keyword">from</span> <span class="string">"@angular/core"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">"greet"</span>,</span><br><span class="line">  template: <span class="string">"&lt;div&gt; Hello, &#123;&#123;name&#125;&#125;! &lt;/div&gt;"</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> GreetComponent &#123;</span><br><span class="line">  <span class="meta">@Input</span>() name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经<code>ngtsc</code>编译后，产物会大概长这个样子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">GreetComponent.ɵcmp = i0.ɵɵdefineComponent(&#123;</span><br><span class="line">  type: GreetComponent,</span><br><span class="line">  tag: <span class="string">"greet"</span>,</span><br><span class="line">  factory: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> GreetComponent(),</span><br><span class="line">  template: <span class="function"><span class="keyword">function</span> (<span class="params">rf, ctx</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建模式下</span></span><br><span class="line">    <span class="keyword">if</span> (rf &amp; RenderFlags.Create) &#123;</span><br><span class="line">      i0.ɵɵelementStart(<span class="number">0</span>, <span class="string">"div"</span>);</span><br><span class="line">      i0.ɵɵtext(<span class="number">1</span>);</span><br><span class="line">      i0.ɵɵelementEnd();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新模式下</span></span><br><span class="line">    <span class="keyword">if</span> (rf &amp; RenderFlags.Update) &#123;</span><br><span class="line">      i0.ɵɵadvance(<span class="number">1</span>);</span><br><span class="line">      i0.ɵɵtextInterpolate1(<span class="string">"Hello "</span>, ctx.name, <span class="string">"!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以看到，创建模式下的模板函数逻辑，与更新视图模式下的模板函数逻辑是有区别的。在创建模式下，<code>elementStart</code>、<code>elementEnd</code>我们在上一篇文章中有详细地介绍了。而在更新模式下，<code>textInterpolate1</code>表示当文本节点有 1 个内插值时，使用由其他文本包围的单个绑定值更新文本内容：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">interpolation1</span>(<span class="params">lView: LView, prefix: <span class="built_in">string</span>, v0: <span class="built_in">any</span>, suffix: <span class="built_in">string</span></span>): <span class="title">string</span>|</span></span><br><span class="line"><span class="function">    <span class="title">NO_CHANGE</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> different = bindingUpdated(lView, nextBindingIndex(), v0);</span><br><span class="line">  <span class="keyword">return</span> different ? prefix + renderStringify(v0) + suffix : NO_CHANGE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以见到，在具体的模板函数指令中，会自行进行变更的检查，如果有发生了变化，则进行更新。<code>bindingUpdated()</code>方法会在需要更改时更新绑定，然后返回是否已更新。</p><p>而对于视图更新时，除了<code>textInterpolate1</code>这种比较简单的场景下的模板更新，子组件通过<code>refreshComponent</code>来处理：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">refreshComponent</span>(<span class="params">hostLView: LView, componentHostIdx: <span class="built_in">number</span></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  ngDevMode &amp;&amp; assertEqual(isCreationMode(hostLView), <span class="literal">false</span>, <span class="string">'Should be run in update mode'</span>);</span><br><span class="line">  <span class="keyword">const</span> componentView = getComponentLViewByIndex(componentHostIdx, hostLView);</span><br><span class="line">  <span class="comment">// 仅应刷新 CheckAlways 或 OnPush 且 Dirty 的附加组件</span></span><br><span class="line">  <span class="keyword">if</span> (viewAttachedToChangeDetector(componentView)) &#123;</span><br><span class="line">    <span class="keyword">const</span> tView = componentView[TVIEW];</span><br><span class="line">    <span class="keyword">if</span> (componentView[FLAGS] &amp; (LViewFlags.CheckAlways | LViewFlags.Dirty)) &#123;</span><br><span class="line">      <span class="comment">// 此处检测组件是否被标记为 CheckAlways 或者 Dirty，此时才进行该组件的视图更新</span></span><br><span class="line">      refreshView(tView, componentView, tView.template, componentView[CONTEXT]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (componentView[TRANSPLANTED_VIEWS_TO_REFRESH] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 仅应刷新 CheckAlways 或 OnPush 且脏的附加组件</span></span><br><span class="line">      refreshContainsDirtyView(componentView);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，在处理子组件的时候，需要检查子组件是否被标记为 CheckAlways 或者 Dirty，才进入组件视图并处理其绑定、查询等来刷新组件。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>以上，便是 Angular Ivy 中的变更检测了。</p><p>可以看到，在 Angular 中将被标记为 CheckAlways 或者 Dirty 的组件进行视图刷新，在每个变更周期中，会执行<code>template()</code>模板函数中的更新模式下逻辑。而在<code>template()</code>模板函数中的具体指令逻辑中，还会根据原来的值和新的值进行比较，有差异的时候才会进行更新。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://indepth.dev/posts/1271/angular-ivy-change-detection-execution-are-you-prepared" target="_blank" rel="noopener">Angular Ivy change detection execution: are you prepared?</a></li><li><a href="https://indepth.dev/posts/1062/ivy-engine-in-angular-first-in-depth-look-at-compilation-runtime-and-change-detection" target="_blank" rel="noopener">Ivy engine in Angular: first in-depth look at compilation, runtime and change detection</a></li><li><a href="https://indepth.dev/posts/1053/everything-you-need-to-know-about-change-detection-in-angular" target="_blank" rel="noopener">Everything you need to know about change detection in Angular</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为“为大型前端项目”而设计的前端框架，Angular 其实有许多值得参考和学习的设计，本系列主要用于研究这些设计和功能的实现原理。本文围绕 Angular 的核心功能 Ivy 编译器，介绍其中变更检测的过程。&lt;/p&gt;
    
    </summary>
    
      <category term="Angular源码" scheme="https://godbasin.github.io/categories/Angular%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="功能设计" scheme="https://godbasin.github.io/tags/%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>2021 年度总结--冲啊打工人</title>
    <link href="https://godbasin.github.io/2021/12/25/my-2021/"/>
    <id>https://godbasin.github.io/2021/12/25/my-2021/</id>
    <published>2021-12-25T08:00:13.000Z</published>
    <updated>2021-12-25T08:01:10.447Z</updated>
    
    <content type="html"><![CDATA[<p>工作很忙的时候，我们总以为自己除了忙碌以外，什么都没有。但当你仔细去回顾，就会发现：其实每一刻每一秒，我们都没有辜负。</p><a id="more"></a><h2 id="总的来说"><a href="#总的来说" class="headerlink" title="总的来说"></a>总的来说</h2><p>总结一下我的 2021，细细看发现也做了不少事情：</p><ol><li>和别人合写的<a href="https://item.jd.com/13289582.html" target="_blank" rel="noopener">《程序开发原理与实战》</a>这本书历经 2 年终于出版了！！</li><li>自己最喜欢的<a href="https://www.ituring.com.cn/book/2942" target="_blank" rel="noopener">《前端的进击》</a>这本书，最终遗憾地以电子书的方式出版了（::sad::）。</li><li>在编辑的邀请下，第一次尝试做了课程<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=822" target="_blank" rel="noopener">《前端的进击笔记》</a>。</li><li>挤了时间研究自己最喜欢的 Angular 框架，并写了一系列的<a href="http://www.godbasin.com/angular/deep-into-angular/angular-design-0-prestart.html" target="_blank" rel="noopener">《Angular 框架解读》</a>。</li><li>开始玩 B 站（<a href="https://space.bilibili.com/42233366" target="_blank" rel="noopener">id: 被删</a>），尝试做一些前端入门和深入的讲解视频。</li><li>帮忙拍摄《递归》系列视频，主题为<a href="https://mp.weixin.qq.com/s/_BySol8lXoU5Bre-40Lskw" target="_blank" rel="noopener">《保持生长不焦虑，非科班程序媛的进击》</a>。</li><li>给我家猫猫画表情包——<a href="https://sticker.weixin.qq.com/cgi-bin/mmemoticon-bin/emoticonview?oper=single&amp;t=shop/detail&amp;productid=aL2PCfwK/89qO7sF6/+I+UDhfwEjhec2ZNvdnLLJRd/Mc1uPro/vaqwIvQ4/JvfucH1+P4XxvWH+nmdDocf83TL09YaAo13vnpYiiZLoocgY=" target="_blank" rel="noopener">牧羊猪的打工日记系列</a>。</li></ol><p>嗯，大概这就是我的 2021，工作中和工作外都有不少的收获和成长。那么下面，如果你感兴趣的话，听我细细道来呀~</p><h2 id="关于工作"><a href="#关于工作" class="headerlink" title="关于工作"></a>关于工作</h2><h3 id="1-工作经历"><a href="#1-工作经历" class="headerlink" title="1. 工作经历"></a>1. 工作经历</h3><p>这一年的工作经历，和以往有一个共同点：<strong>遇到过新的问题，然后有了新的体会和感受</strong>。</p><p>从 2014 年毕业，后裸辞工作之后自学前端，然后开始慢慢深入学习和开发，一直到如今 2021 年，我几乎每年都有工作变动，几乎都是自己主动发起的调整。</p><p>越来越发现，刚毕业的时候我们都充满热情，到最后大家却逐渐地对“妥协”二字妥协了。这几年互联网行业的确很卷，竞争力和压力也增加了不少，很多人都充满了迷茫和焦虑，而我也增加了不少的疑惑。</p><p>今年的主要思考是：</p><ul><li>作为一名前端开发/程序员，我想要走向哪里？</li><li>职业发展上常说的广度和深度，是不是伪命题？</li><li>团队管理中，一个开发能做的有多少？</li></ul><p>关于这些，每一个点讲起来都可以长篇大论了，我之前在博客有讲相关的内容，包括《关于一年一换的魔咒》、《技术开发的门槛高吗》、《关于技术开发的职业发展》、《技术深度是伪命题吗》，这些你可以在我的<a href="http://www.godbasin.com/front-end-work/front-end-days/about-front-end-11.html" target="_blank" rel="noopener">“被删前端游乐场–前端这几年”</a>分享里找到。</p><h3 id="2-项目经历"><a href="#2-项目经历" class="headerlink" title="2. 项目经历"></a>2. 项目经历</h3><p>这一年的工作经历，和以往也有不同点：第一次接触大型前端项目的难题。</p><p>目前在文档团队，在线文档的编辑和协同对前端来说有不小的挑战。之前也有简单地整理了一篇了解在线文档的文章：<a href="http://www.godbasin.com/front-end-basic/deep-learning/why-spreadsheet-app-excited.html" target="_blank" rel="noopener">《在线 Excel 项目到底有多刺激》</a>，简单来说会包括：</p><ul><li>协同过程中的冲突处理算法</li><li>多人协作时的版本管理和维护</li><li>大文档下的加载和渲染性能、卡顿问题</li><li>文档数据结构的设计和算法</li><li>Canvas 渲染和 DOM 渲染的一致性</li><li>排版引擎的设计和优化</li></ul><p>除了文档本身功能逻辑的难题之外，这样的项目还涉及到代码量过大（100W+）、开发团队人员过多、协作开发和管理等各种各样的难题，包括：</p><ul><li>如何对模块之间进行功能解耦</li><li>如何进行大项目的代码组织和架构设计</li><li>大型前端项目的代码加载流程如何优化</li><li>大团队里多人协作导致的问题和解决方案</li><li>如何保证大型项目的开发效率/可维护性/可读性</li></ul><p>团队里优秀的小伙伴很多，真就每天都能学到不少的知识。即使到今天，我已经来这个团队一年多了，依然对整个项目还有许多地方了解得比较浅。总的来说，<strong>非常有幸参与到这样的项目里，让我可以在前端领域工作的第 6 年里，依然有无数种让自己获得成长的方式</strong>。</p><p>以上便是是工作相关的，虽然今年也有介于团队调整空白期的懈怠，但在即将结束的 2021 年底前，顺利地将自己的状态调整过来，这是值得开心的事情。</p><h3 id="3-工作外的技术成长"><a href="#3-工作外的技术成长" class="headerlink" title="3. 工作外的技术成长"></a>3. 工作外的技术成长</h3><p>主要有三点：</p><ol><li>技术博客的更新–<a href="https://github.com/godbasin/front-end-playground" target="_blank" rel="noopener">被删的前端游乐场</a>。</li><li>技术书的出版。</li><li>技术课程的制作–<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=822" target="_blank" rel="noopener">《前端的进击笔记》</a>。</li><li>技术视频的制作–<a href="https://space.bilibili.com/42233366/channel/seriesdetail?sid=372770" target="_blank" rel="noopener">《前端开发那些事》</a>。</li></ol><p>2021 年，我的技术博客一如既往地在更新，今年在业余时间去研究了下自己很喜欢的 Angular 框架，并写了一系列的<a href="http://www.godbasin.com/angular/deep-into-angular/angular-design-0-prestart.html" target="_blank" rel="noopener">《Angular 框架解读》</a>。除此之外，我也写了一些工作上的思考内容，更新了好久没写的前端工作系列。</p><p>今年出版了两本书，一本纸质书和一本电子书，算上之前写的一本开源书，目前我一个写了三本技术书了：</p><ul><li><a href="https://item.jd.com/13289582.html" target="_blank" rel="noopener">纸质书《程序开发原理与实战》</a></li><li><a href="https://www.ituring.com.cn/book/2942" target="_blank" rel="noopener">电子书《前端的进击》</a></li><li><a href="http://www.godbasin.com/vue-ebook/" target="_blank" rel="noopener">开源书《深入理解 Vue.js 实战》</a></li></ul><p>其中，我最喜欢的书是《前端的进击》这一本。最开始为什么想写这本书呢？主要是因为自己这几年的工作经历也比较折腾，认识和学到了很多。但反观身边的很多小伙伴，尤其是刚毕业的应届生们，他们会存在很多很多的疑惑，也没有人告诉他们该怎么做，很多时候会陷入自我怀疑的困境。</p><p>他们遇到的这些问题，有些只需要调整下自身的工作方式和状态，有一些需要通过有效的沟通去解决，还有一些则是大环境下的常见问题。职场工作和校园学习相差很远，刚开始工作的那几年，很可能就决定了以后对工作、对这个行业的认知和价值观。</p><p><strong>很多很多的事情，它们都没有标准答案，都需要每个人自己去进行探索和思考。</strong></p><p>因此，我把自己的工作方法和思考写下来，希望能对一些正感到困惑的人给到帮助。这就是这本书的初衷，我非常希望在遇到一些“不对劲”的事情时，他们能少一些的自我怀疑，接受预期之外的事情发生，同时能坚持住自己的初心。</p><p>后来，在编辑的鼓励下，我给这本书画了很多的插画，包括这本书封面的猫猫也是我画的:</p><p>&lt;img src=<a href="https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/%E5%89%8D%E7%AB%AF%E7%9A%84%E8%BF%9B%E5%87%BB.jpg" target="_blank" rel="noopener">https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/%E5%89%8D%E7%AB%AF%E7%9A%84%E8%BF%9B%E5%87%BB.jpg</a> width=60% /&gt;</p><p>再后来，这本书因为审核时出版社考虑成本的原因，无法进行纸质书的销售，尝试加上了加一些硬技能的内容，变成了三大部分：前端基础和入门、提升硬实力、必备软实力。但还是无法出版纸质书，最终以电子书的方式出版了，这大概是我和编辑小姐姐都特别遗憾的事情了。</p><blockquote><p>如果你对这本书的写作过程感兴趣，也可以来看看<a href="http://www.godbasin.com/front-end-work/front-end-days/a-book-with-one-story.html" target="_blank" rel="noopener">《一本书和一个故事》</a>。</p></blockquote><h2 id="生活中的新尝试"><a href="#生活中的新尝试" class="headerlink" title="生活中的新尝试"></a>生活中的新尝试</h2><p>如果要概括 2021 年的生活，主题大概是：<strong>多去尝试做一些新的事情</strong>。</p><p>今年这些事情包括：拍视频、画插画、做视频、画表情包，这些都是我以前没有尝试过去做的，但是做的时候觉得特别开心。</p><h3 id="1-画的表情包和插画"><a href="#1-画的表情包和插画" class="headerlink" title="1. 画的表情包和插画"></a>1. 画的表情包和插画</h3><p><img src="https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/%E5%86%8D%E8%A7%812020_LOGO_%E7%94%BB%E6%9D%BF%201_%E7%94%BB%E6%9D%BF%201.png" alt></p><p><img src="https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/biaoqingbao123.jpg" alt></p><h3 id="2-做了很多视频"><a href="#2-做了很多视频" class="headerlink" title="2. 做了很多视频"></a>2. 做了很多视频</h3><ul><li><a href="https://space.bilibili.com/42233366/channel/detail?cid=182293" target="_blank" rel="noopener">前端开发那些事</a>：主要是一些入门和深入的技术路线，比较推荐前端进阶路线、前端算法等内容</li><li><a href="https://space.bilibili.com/42233366/channel/detail?cid=186484" target="_blank" rel="noopener">程序员段子</a>:主要是一些日常工作里的灵感段子，自己配音常常笑到肚子疼</li><li><a href="https://space.bilibili.com/42233366/channel/detail?cid=190754" target="_blank" rel="noopener">程序员日志</a>：主要是自己的工作相关的心路历程和思考</li><li><a href="https://space.bilibili.com/42233366/channel/detail?cid=197803" target="_blank" rel="noopener">Angular 冷知识</a>：介绍前端  Angular 框架中比较有意思的设计和实现原理，基于最近在研究的 Angular 源码整理讲的，会比博客上的文章容易理解一些</li><li><a href="https://space.bilibili.com/42233366/channel/detail?cid=184764" target="_blank" rel="noopener">牧羊猪猫猫</a>：我家猫猫的日常，特别可爱欢迎在线吸猫哈哈哈哈</li></ul><h3 id="3-偶尔写些生活记录"><a href="#3-偶尔写些生活记录" class="headerlink" title="3. 偶尔写些生活记录"></a>3. 偶尔写些生活记录</h3><p>生活上的事情，会记录在自己的公众号（叫“牧羊的猪”）里。</p><p>公众号写了很多年了，偶尔会写一些最近的生活和工作状态。虽然没什么人关注，但感觉是属于自己的一个世界，很喜欢在写生活记录时，这样自己和自己对话的过程。</p><h3 id="4-猪猪真的太可爱了"><a href="#4-猪猪真的太可爱了" class="headerlink" title="4. 猪猪真的太可爱了"></a>4. 猪猪真的太可爱了</h3><p>2021 我的超人：猪猪！！</p><p><img src="https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/368f7230e349a45b3ff48e789f1f516.jpg" alt></p><p><img src="https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/0b0c53771f81f51344e82bce9fb4bf0.jpg" alt></p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>原本我以为，今年过得好像有点浑浑噩噩，没什么成长和长进。</p><p>但是当我开始这么一点点回顾和记录 2021 这一年来的事情时，我发现自己其实还是做了很多事情的。下周就会迎来新的一年了，希望明年也能保持这样一个劲头，多去尝试多去体验，做一个开开心心的自己！！</p><p>最后祝各位 2022 年一切都顺利！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作很忙的时候，我们总以为自己除了忙碌以外，什么都没有。但当你仔细去回顾，就会发现：其实每一刻每一秒，我们都没有辜负。&lt;/p&gt;
    
    </summary>
    
      <category term="工作这杯茶" scheme="https://godbasin.github.io/categories/%E5%B7%A5%E4%BD%9C%E8%BF%99%E6%9D%AF%E8%8C%B6/"/>
    
    
      <category term="心态" scheme="https://godbasin.github.io/tags/%E5%BF%83%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>前端这几年--14.技术深度是伪命题吗</title>
    <link href="https://godbasin.github.io/2021/12/12/about-front-end-14/"/>
    <id>https://godbasin.github.io/2021/12/12/about-front-end-14/</id>
    <published>2021-12-12T06:55:12.000Z</published>
    <updated>2021-12-12T07:29:30.132Z</updated>
    
    <content type="html"><![CDATA[<p>最近在思考，我们常说的技术广度和深度，在实际工作中到底指代什么？怎样的工作是有深度？怎样的技术是广度呢？</p><a id="more"></a><h2 id="技术深度到底是指什么？"><a href="#技术深度到底是指什么？" class="headerlink" title="技术深度到底是指什么？"></a>技术深度到底是指什么？</h2><p><a href="https://godbasin.github.io/2021/11/28/about-front-end-13/">上一篇</a> 聊技术开的职业发展，其实也有讲到技术深度和广度的问题，但我觉得这个问题可以再进行更多的探讨。</p><p>在过去工作的这么多年来，我一直认为：只有在某个技术领域达到足够的深度，才能保持自己在该行业的竞争力。这也是我在某段职业发展规划中的方向，其中的几次换工作，都往“更大的平台和团队”、“更复杂的业务”这样的方向去走。</p><p>实际上，在各个团队和项目中的一些经历，让我重新思考起来，我们常说的所谓技术深度，到底是指什么呢？</p><h3 id="复杂的业务真的复杂吗？"><a href="#复杂的业务真的复杂吗？" class="headerlink" title="复杂的业务真的复杂吗？"></a>复杂的业务真的复杂吗？</h3><p>我们经常会调侃自己的工作，比如切图仔、CRUD 工程师、调参工程师。很多时候，当我们掌握了当前工作涉及的技术和技巧之后，剩余的常常只有重复枯燥的工作日常，比如查 BUG、写 BUG、和产品同学扯皮、和测试同学吵架、用夸张手法写汇报，等等。</p><p>当我在做一些自认为简单的业务时，就会向往复杂的业务。在我的经历中，在业务场景比较简单的时候，大家为了晋级和考核，都倾向于将简单的事情变复杂，然后再用“有难度”的解决方案去解决，正所谓“没事找事”。那时候我觉得，如果业务本身足够复杂，就会有足够多的事情值得去解决，而不需要凭空捏造出这些复杂的场景，更不需要为了让解决方案看起来复杂，而特意让业务逻辑变得复杂。</p><p>在复杂的业务团队里，的确会有特别多的新知识和技术可以学习，也可以接触到大的业务场景下不同的领域模块。但实际上，对于大多数开发的日常工作，依然是基于某块业务的开发和维护，或是由于业务过于复杂，每天都被各种模块间的耦合相互影响、依赖各种上下游、莫名其妙出现的 BUG 等等，也没有足够的时间去研究。</p><p>而当我开始尝试解决以前认为足够复杂的业务场景时，发现再复杂的问题，也依然可以将其梳理并一一拆解，然后再逐个击破去解决。在工程化的业务里，我们用到的 99% 的技术方案，几乎都是通过现有的一些技术方案，进行适配、改造、调整后，尝试在业务中落地。以前我觉得涉及到算法和数据结构的业务，可能会面临较大的挑战、有足够的技术深度。但实际上，我们也还是在参考业界的方案，或是研究已发布的论文，结合业务的痛点去尝试解决。</p><p>技术调研、工程落地、项目管理这样的技能在工作中的占比更大，但它们似乎更倾向于职场技巧而不是专业技能，于是我不禁怀疑：怎样的工作内容才能算作是有技术深度呢？</p><h3 id="简单的业务真的简单吗？"><a href="#简单的业务真的简单吗？" class="headerlink" title="简单的业务真的简单吗？"></a>简单的业务真的简单吗？</h3><p>以前所在的一个业务团队，团队的业务核心偏向后台，于是整体上会对前端不够重视，不管是考核还是晋级都是前后端一起，评委也基本都是是后台开发。</p><p>作为前端开发，在这样的团队里成长很局限，包括前端的基础建设有很多问题、整体的技术栈都很落后、前端相关的优化不被重视等等。虽然我也做了很多的事情尝试去推动，但后面被告知需要做一个对团队和业务“更有价值”的事情，才能拿到好的考核。于是，我离开了（当然，技术成长只是团队的其中一个问题而已）。</p><p>在走了一段时间之后，同一个大团队的其他小分队找我，问我要不要去他们那边，说很缺有能力的前端开发。当我提到业务比较简单的时候，对方说了一句：都说业务简单简单，为什么就是有很多问题、做不好呢？</p><p>于是，我又陷入了沉思。</p><p>的确，该类型的业务对前端来说，或许技术栈比较简单，无非就是小程序或是常见的前端框架套件。但实际上由于这块一直被轻视，甚至大家都认为后端开发也能轻松实现一些前端功能，而我看见的常常是“复制粘贴+改变量名”的方式来实现功能，可想而知再简单的业务也能被维护得足够复杂。</p><p>再者，业务场景虽然简单，但用户量、安全等要求都比较高，因此对数据上报、监控治理有较大的要求，这方面很少有人愿意去把它做好，而实际上要持续地维护好也并不是那么容易的。</p><p>所以，再简单的业务场景，都存在可以优化的地方，“把每一个细节仔细剖析再层层研究”，能做到的人又有多少呢？但要能做到这一点的人，不管在怎样的业务和团队里，都能持续不断地学到新的知识、获得更多的经验，不管是广度还是深度。</p><h3 id="技术深度是伪命题吗？"><a href="#技术深度是伪命题吗？" class="headerlink" title="技术深度是伪命题吗？"></a>技术深度是伪命题吗？</h3><p>最近会跟一些朋友讨论这个话题：技术深度到底是不是伪命题？</p><p>我的想法是，所谓的技术深度，大多数时候都是由自己的工作经历和项目经验决定的。有些开发的工作中接触到的技术范围较广，所以会有“技术广度”；有些开发在工作中一直接触某个领域的业务，那么他便会拥有该垂直领域的“技术深度”。</p><p>有个朋友举了个例子，说他认为技术深度的确会存在，因为他们曾经遇到过一个大家都觉得“莫名其妙”的问题，是一位 P8 的技术专家一层层剖析解开，最终发现是某个十分底层系统中使用的网络包存在缺陷。他认为，大多数的开发能力是不足以定位到如此深入和细致的问题的。</p><p>我的看法不大一样，或许是这位技术专家以前有过相关经验，不管是曾经遇到过类似的问题也好，还是他对问题定位有自己成熟的经验和方法，这都是由他过去的工作经历决定的。一个一直基于某个领域深挖的技术开发，只要不止步于前，经验和时间的沉淀都会给他带来在这个领域足够的深度。同样的，如果在各个领域间不断转换和研究的技术开发，也可以在广度方向上有足够多的经验和沉淀。当然，对比如今很多只说不做、用漂亮的汇报话术和 PPT 成为技术专家的开发来说，这样能在关键时刻替大家解决问题、而不是指指点点的开发才称得上为真正的专家。</p><p>只能说，如今的行业状态是，很多人可以凭借“表现”和“包装”获得好的考核和职级，因此总有一些技术管理或是技术专家并不能真正地让人信服。相比之下，凭借扎实的项目经验和解决问题能力往上走的开发，很多时候则是被大家成为“技术很强”的专家了。大多数时候，我们追求的所谓“技术深度”，大概也便是这样了。</p><p>当然，广度和深度的要求还是有差别的。大多数时候追求广度容易“泛而不精”，而追求深度则可能领域外“一窍不通”，对于每个希望成为技术专家的人来说，做好广度和深度的平衡也是职业发展中重要的一环。</p><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>在我看来，每个人的技术能力，不管是深度还是广度，都跟自身的经历和成长有关系。简单说来，过去的经验造就了每一个开发，而是否能有效地发挥和吸收这些经验，决定了不同开发的技术能力和成长速度。</p><p>所以，在职业规划的时候，也不必太过执着于做的事情是否足够复杂、是否有更好的晋级/考核机会、是否是自己想要的广度或是深度，光是认真而踏实地把手上的每一件事做好，就可以收获足够的成长了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在思考，我们常说的技术广度和深度，在实际工作中到底指代什么？怎样的工作是有深度？怎样的技术是广度呢？&lt;/p&gt;
    
    </summary>
    
      <category term="工作这杯茶" scheme="https://godbasin.github.io/categories/%E5%B7%A5%E4%BD%9C%E8%BF%99%E6%9D%AF%E8%8C%B6/"/>
    
    
      <category term="分享" scheme="https://godbasin.github.io/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>Angular框架解读--Ivy编译器之增量DOM</title>
    <link href="https://godbasin.github.io/2021/12/05/angular-design-ivy-5-incremental-dom/"/>
    <id>https://godbasin.github.io/2021/12/05/angular-design-ivy-5-incremental-dom/</id>
    <published>2021-12-05T02:25:13.000Z</published>
    <updated>2021-12-05T02:53:13.531Z</updated>
    
    <content type="html"><![CDATA[<p>作为“为大型前端项目”而设计的前端框架，Angular 其实有许多值得参考和学习的设计，本系列主要用于研究这些设计和功能的实现原理。本文围绕 Angular 的核心功能 Ivy 编译器，介绍其中的增量 DOM 设计。</p><a id="more"></a><p>在介绍前端框架的时候，我常常会介绍到模板引擎。对于模板引擎的渲染过程，像 Vue/React 这样的框架里，使用了虚拟 DOM 这样的设计。</p><p>在 Angular Ivy 编译器中，并没有使用虚拟 DOM，而且使用了增量 DOM。</p><h2 id="增量-DOM"><a href="#增量-DOM" class="headerlink" title="增量 DOM"></a>增量 DOM</h2><p>前面在<a href="https://godbasin.github.io/2021/08/15/angular-design-ivy-0-design/">《Angular 框架解读–Ivy 编译器整体设计》</a>一文中，我有介绍在 Ivy 编译器里，模板编译后的产物与 View Engine 不一样了，这是为了支持单独编译、增量编译等能力。</p><p>比如，<code>&lt;span&gt;My name is &lt;/span&gt;</code>这句模板代码，在 Ivy 编译器中编译后的代码大概长这个样子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create mode</span></span><br><span class="line"><span class="keyword">if</span> (rf &amp; RenderFlags.Create) &#123;</span><br><span class="line">  elementStart(<span class="number">0</span>, <span class="string">"span"</span>);</span><br><span class="line">  text(<span class="number">1</span>);</span><br><span class="line">  elementEnd();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// update mode</span></span><br><span class="line"><span class="keyword">if</span> (rf &amp; RenderFlags.Update) &#123;</span><br><span class="line">  textBinding(<span class="number">1</span>, interpolation1(<span class="string">"My name is"</span>, ctx.name));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，相比于 View Engine 中的<code>elementDef(0,null,null,1,&#39;span&#39;,...),</code>，<code>elementStart()</code>、<code>elementEnd()</code>这些 API 显得更加清爽，它们使用的便是增量 DOM 的设计。</p><h3 id="增量-DOM-vs-虚拟-DOM"><a href="#增量-DOM-vs-虚拟-DOM" class="headerlink" title="增量 DOM vs 虚拟 DOM"></a>增量 DOM vs 虚拟 DOM</h3><p>虚拟 DOM 想必大家都已经有所了解，它的核心计算过程包括：</p><ol><li>用 JavaScript 对象模拟 DOM 树，得到一棵虚拟 DOM 树。</li><li>当页面数据变更时，生成新的虚拟 DOM 树，比较新旧两棵虚拟 DOM 树的差异。</li><li>把差异应用到真正的 DOM 树上。</li></ol><p>虽然虚拟 DOM 解决了页面被频繁更新和渲染带来的性能问题，但传统虚拟 DOM 依然有以下性能瓶颈：</p><ul><li>在单个组件内部依然需要遍历该组件的整个虚拟 DOM 树</li><li>在一些组件整个模版内只有少量动态节点的情况下，这些遍历都是性能的浪费</li><li>递归遍历和更新逻辑容易导致 UI 渲染被阻塞，用户体验下降</li></ul><p>针对这些情况，React 和 Vue 等框架也有更多的优化，比如 React 中分别对 tree diff、component diff 以及 element diff 进行了算法优化，同时引入了任务调度来控制状态更新的计算和渲染。在 Vue 3.0 中，则将虚拟 DOM 的更新从以前的整体作用域调整为树状作用域，树状的结构会带来算法的简化以及性能的提升。</p><p>而不管怎样，虚拟 DOM 的设计中存在一个无法避免的问题：每个渲染操作分配一个新的虚拟 DOM 树，该树至少大到足以容纳发生变化的节点，并且通常更大一些，这样的设计会导致更多的一些内存占用。当大型虚拟 DOM 树需要大量更新时，尤其是在内存受限的移动设备上，性能可能会受到影响。</p><p>增量 DOM 的设计核心思想是：</p><ol><li>在创建新的（虚拟）DOM 树时，沿着现有的树走，并在进行时找出更改。</li><li>如果没有变化，则不分配内存；</li><li>如果有，改变现有树（仅在绝对必要时分配内存）并将差异应用到物理 DOM。</li></ol><p>这里将（虚拟）放在括号中是因为，当将预先计算的元信息混合到现有 DOM 节点中时，使用物理 DOM 树而不是依赖虚拟 DOM 树实际上已经足够快了。</p><p>与基于虚拟 DOM 的方法相比，增量 DOM 有两个主要优势：</p><ul><li>增量特性允许在渲染过程中显着减少内存分配，从而实现更可预测的性能</li><li>它很容易映射到基于模板的方法。控制语句和循环可以与元素和属性声明自由混合</li></ul><p>增量 DOM 的设计由 Google 提出，同时他们也提供了一个开源库 <a href="https://github.com/google/incremental-dom" target="_blank" rel="noopener">google/incremental-dom</a>，它是一个用于表达和应用 DOM 树更新的库。JavaScript 可用于提取、迭代数据并将其转换为生成 HTMLElements 和 Text 节点的调用。</p><p>但新的 Ivy 引擎没有直接使用它，而是实现了自己的版本。</p><h2 id="Ivy-中的增量-DOM"><a href="#Ivy-中的增量-DOM" class="headerlink" title="Ivy 中的增量 DOM"></a>Ivy 中的增量 DOM</h2><p>Ivy 引擎基于增量 DOM 的概念，它与虚拟 DOM 方法的不同之处在于，diff 操作是针对 DOM 增量执行的（即一次一个节点），而不是在虚拟 DOM 树上执行。基于这样的设计，增量 DOM 与 Angular 中的脏检查机制其实能很好地搭配。</p><h3 id="增量-DOM-元素创建"><a href="#增量-DOM-元素创建" class="headerlink" title="增量 DOM 元素创建"></a>增量 DOM 元素创建</h3><p>增量 DOM 的 API 的一个独特功能是它分离了标签的打开（<code>elementStart</code>）和关闭（<code>elementEnd</code>），因此它适合作为模板语言的编译目标，这些语言允许（暂时）模板中的 HTML 不平衡（比如在单独的模板中，打开和关闭的标签）和任意创建 HTML 属性的逻辑。</p><p>在 Ivy 中，使用<code>elementStart</code>和<code>elementEnd</code>创建一个空的 Element 实现如下（在 Ivy 中，<code>elementStart</code>和<code>elementEnd</code>的具体实现便是<code>ɵɵelementStart</code>和<code>ɵɵelementEnd</code>）：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> ɵɵ<span class="title">element</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  index: <span class="built_in">number</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  name: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  attrsIndex?: <span class="built_in">number</span> | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  localRefsIndex?: <span class="built_in">number</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  ɵɵelementStart(index, name, attrsIndex, localRefsIndex);</span><br><span class="line">  ɵɵelementEnd();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>ɵɵelementStart</code>用于创建 DOM 元素，该指令后面必须跟有<code>ɵɵelementEnd()</code>调用。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> ɵɵ<span class="title">elementStart</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  index: <span class="built_in">number</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  name: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  attrsIndex?: <span class="built_in">number</span> | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  localRefsIndex?: <span class="built_in">number</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> lView = getLView();</span><br><span class="line">  <span class="keyword">const</span> tView = getTView();</span><br><span class="line">  <span class="keyword">const</span> adjustedIndex = HEADER_OFFSET + index;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> renderer = lView[RENDERER];</span><br><span class="line">  <span class="comment">// 此处创建 DOM 元素</span></span><br><span class="line">  <span class="keyword">const</span> native = (lView[adjustedIndex] = createElementNode(</span><br><span class="line">    renderer,</span><br><span class="line">    name,</span><br><span class="line">    getNamespace()</span><br><span class="line">  ));</span><br><span class="line">  <span class="comment">// 获取 TNode</span></span><br><span class="line">  <span class="comment">// 在第一次模板传递中需要收集匹配</span></span><br><span class="line">  <span class="keyword">const</span> tNode = tView.firstCreatePass ?</span><br><span class="line">      elementStartFirstCreatePass(</span><br><span class="line">          adjustedIndex, tView, lView, native, name, attrsIndex, localRefsIndex) :</span><br><span class="line">      tView.data[adjustedIndex] <span class="keyword">as</span> TElementNode;</span><br><span class="line">  setCurrentTNode(tNode, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> mergedAttrs = tNode.mergedAttrs;</span><br><span class="line">  <span class="comment">// 通过推断的渲染器，将所有属性值分配给提供的元素</span></span><br><span class="line">  <span class="keyword">if</span> (mergedAttrs !== <span class="literal">null</span>) &#123;</span><br><span class="line">    setUpAttributes(renderer, native, mergedAttrs);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将 className 写入 RElement</span></span><br><span class="line">  <span class="keyword">const</span> classes = tNode.classes;</span><br><span class="line">  <span class="keyword">if</span> (classes !== <span class="literal">null</span>) &#123;</span><br><span class="line">    writeDirectClass(renderer, native, classes);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将 cssText 写入 RElement</span></span><br><span class="line">  <span class="keyword">const</span> styles = tNode.styles;</span><br><span class="line">  <span class="keyword">if</span> (styles !== <span class="literal">null</span>) &#123;</span><br><span class="line">    writeDirectStyle(renderer, native, styles);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((tNode.flags &amp; TNodeFlags.isDetached) !== TNodeFlags.isDetached) &#123;</span><br><span class="line">    <span class="comment">// 添加子元素</span></span><br><span class="line">    appendChild(tView, lView, native, tNode);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 组件或模板容器的任何直接子级，必须预先使用组件视图数据进行猴子修补</span></span><br><span class="line">  <span class="comment">// 以便稍后可以使用任何元素发现实用程序方法检查元素</span></span><br><span class="line">  <span class="keyword">if</span> (getElementDepthCount() === <span class="number">0</span>) &#123;</span><br><span class="line">    attachPatchData(native, lView);</span><br><span class="line">  &#125;</span><br><span class="line">  increaseElementDepthCount();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对指令 Host 的处理</span></span><br><span class="line">  <span class="keyword">if</span> (isDirectiveHost(tNode)) &#123;</span><br><span class="line">    createDirectivesInstances(tView, lView, tNode);</span><br><span class="line">    executeContentQueries(tView, tNode, lView);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取本地名称和索引的列表，并将解析的本地变量值按加载到模板中的相同顺序推送到 LView</span></span><br><span class="line">  <span class="keyword">if</span> (localRefsIndex !== <span class="literal">null</span>) &#123;</span><br><span class="line">    saveResolvedLocalsInData(lView, tNode);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在<code>ɵɵelementStart</code>创建 DOM 元素的过程中，主要依赖于<code>LView</code>、<code>TView</code>和<code>TNode</code>。</p><p>在 Angular Ivy 中，使用了<code>LView</code>和<code>TView.data</code>来管理和跟踪渲染模板所需要的内部数据。对于<code>TNode</code>，在 Angular 中则是用于在特定类型的所有模板之间共享的特定节点的绑定数据（享元）。关于视图数据相关内容，之前在<a href="https://godbasin.github.io/2021/09/19/angular-design-ivy-1-view-data-and-node-injector/">《Angular 框架解读–Ivy 编译器的视图数据和依赖解析》</a>一节便介绍过了，因此这里不再做详细的介绍。</p><p><code>ɵɵelementEnd()</code>则用于标记元素的结尾：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> ɵɵ<span class="title">elementEnd</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>对于<code>ɵɵelementEnd()</code>的详细实现不过多介绍，基本上主要包括一些对 Class 和样式中<code>@input</code>等指令的处理，循环遍历提供的<code>tNode</code>上的指令、并将要运行的钩子排入队列，元素层次的处理等等。</p><h3 id="组件创建与增量-DOM-指令"><a href="#组件创建与增量-DOM-指令" class="headerlink" title="组件创建与增量 DOM 指令"></a>组件创建与增量 DOM 指令</h3><p>在增量 DOM 中，每个组件都被编译成一系列指令。这些指令创建 DOM 树并在数据更改时就地更新它们。</p><p>Ivy 在运行时编译一个组件的过程中，会创建模板解析相关指令：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">compileComponentFromMetadata</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  meta: R3ComponentMetadata,</span></span></span><br><span class="line"><span class="function"><span class="params">  constantPool: ConstantPool,</span></span></span><br><span class="line"><span class="function"><span class="params">  bindingParser: BindingParser</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">R3ComponentDef</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 其他暂时省略</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个 TemplateDefinitionBuilder，用于创建模板相关的处理</span></span><br><span class="line">  <span class="keyword">const</span> templateBuilder = <span class="keyword">new</span> TemplateDefinitionBuilder(</span><br><span class="line">      constantPool, BindingScope.createRootScope(), <span class="number">0</span>, templateTypeName, <span class="literal">null</span>, <span class="literal">null</span>, templateName,</span><br><span class="line">      directiveMatcher, directivesUsed, meta.pipes, pipesUsed, R3.namespaceHTML,</span><br><span class="line">      meta.relativeContextFilePath, meta.i18nUseExternalIds);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建模板解析相关指令，包括：</span></span><br><span class="line">  <span class="comment">// 第一轮：创建模式，包括所有创建模式指令（例如解析侦听器中的绑定）</span></span><br><span class="line">  <span class="comment">// 第二轮：绑定和刷新模式，包括所有更新模式指令（例如解析属性或文本绑定）</span></span><br><span class="line">  <span class="keyword">const</span> templateFunctionExpression = templateBuilder.buildTemplateFunction(template.nodes, []);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提供这个以便动态生成的组件在实例化时，知道哪些投影内容块要传递给组件</span></span><br><span class="line">  <span class="keyword">const</span> ngContentSelectors = templateBuilder.getNgContentSelectors();</span><br><span class="line">  <span class="keyword">if</span> (ngContentSelectors) &#123;</span><br><span class="line">    definitionMap.set(<span class="string">"ngContentSelectors"</span>, ngContentSelectors);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生成 ComponentDef 的 consts 部分</span></span><br><span class="line">  <span class="keyword">const</span> &#123; constExpressions, prepareStatements &#125; = templateBuilder.getConsts();</span><br><span class="line">  <span class="keyword">if</span> (constExpressions.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> constsExpr: o.LiteralArrayExpr|o.FunctionExpr = o.literalArr(constExpressions);</span><br><span class="line">    <span class="comment">// 将 consts 转换为函数</span></span><br><span class="line">    <span class="keyword">if</span> (prepareStatements.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      constsExpr = o.fn([], [...prepareStatements, <span class="keyword">new</span> o.ReturnStatement(constsExpr)]);</span><br><span class="line">    &#125;</span><br><span class="line">    definitionMap.set(<span class="string">"consts"</span>, constsExpr);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生成 ComponentDef 的 template 部分</span></span><br><span class="line">  definitionMap.set(<span class="string">"template"</span>, templateFunctionExpression);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，在组件编译时，会被编译成一系列的指令，包括<code>const</code>、<code>vars</code>、<code>directives</code>、<code>pipes</code>、<code>styles</code>、<code>changeDetection</code>等等，当然也包括<code>template</code>模板里的相关指令。最终生成的这些指令，会体现在编译后的组件中，比如前面<a href>《Angular 框架解读–Ivy 编译器之心智模型》</a>中提到的这样一个<code>Component</code>文件：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, Input &#125; <span class="keyword">from</span> <span class="string">"@angular/core"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">"greet"</span>,</span><br><span class="line">  template: <span class="string">"&lt;div&gt; Hello, &#123;&#123;name&#125;&#125;! &lt;/div&gt;"</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> GreetComponent &#123;</span><br><span class="line">  <span class="meta">@Input</span>() name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经<code>ngtsc</code>编译后，产物包括该组件的<code>.js</code>文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> i0 = <span class="built_in">require</span>(<span class="string">"@angular/core"</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetComponent</span> </span>&#123;&#125;</span><br><span class="line">GreetComponent.ɵcmp = i0.ɵɵdefineComponent(&#123;</span><br><span class="line">  type: GreetComponent,</span><br><span class="line">  tag: <span class="string">"greet"</span>,</span><br><span class="line">  factory: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> GreetComponent(),</span><br><span class="line">  template: <span class="function"><span class="keyword">function</span> (<span class="params">rf, ctx</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rf &amp; RenderFlags.Create) &#123;</span><br><span class="line">      i0.ɵɵelementStart(<span class="number">0</span>, <span class="string">"div"</span>);</span><br><span class="line">      i0.ɵɵtext(<span class="number">1</span>);</span><br><span class="line">      i0.ɵɵelementEnd();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rf &amp; RenderFlags.Update) &#123;</span><br><span class="line">      i0.ɵɵadvance(<span class="number">1</span>);</span><br><span class="line">      i0.ɵɵtextInterpolate1(<span class="string">"Hello "</span>, ctx.name, <span class="string">"!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其中，<code>elementStart()</code>、<code>text()</code>、<code>elementEnd()</code>、<code>advance()</code>、<code>textInterpolate1()</code>这些都是增量 DOM 相关的指令。在实际创建组件的时候，其<code>template</code>模板函数也会被执行，相关的指令也会被执行。</p><p>正因为在 Ivy 中，是由组件来引用着相关的模板指令。如果组件不引用某个指令，则我们的 Angular 中永远不会使用到它。因为组件编译的过程发生在编译过程中，因此我们可以根据引用到指令，来排除未引用的指令，从而可以在 Tree-shaking 过程中，将未使用的指令从包中移除，这便是增量 DOM 可树摇的原因。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>现在，我们已经知道在 Ivy 中，是通过编译器将模板编译为<code>template</code>渲染函数，其中会将对模板的解析编译成增量 DOM 相关的指令。其中，在<code>elementStart()</code>执行时，我们可以看到会通过<code>createElementNode()</code>方法来创建 DOM。实际上，增量 DOM 的设计远不止只是创建 DOM，还包括变化检测等各种能力，关于具体的渲染过程，我们会在下一讲中进行介绍。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://medium.com/google-developers/introducing-incremental-dom-e98f79ce2c5f" target="_blank" rel="noopener">Introducing Incremental DOM</a></li><li><a href="https://indepth.dev/posts/1062/ivy-engine-in-angular-first-in-depth-look-at-compilation-runtime-and-change-detection" target="_blank" rel="noopener">Ivy engine in Angular: first in-depth look at compilation, runtime and change detection</a></li><li><a href="https://blog.nrwl.io/understanding-angular-ivy-incremental-dom-and-virtual-dom-243be844bf36" target="_blank" rel="noopener">Understanding Angular Ivy: Incremental DOM and Virtual DOM</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为“为大型前端项目”而设计的前端框架，Angular 其实有许多值得参考和学习的设计，本系列主要用于研究这些设计和功能的实现原理。本文围绕 Angular 的核心功能 Ivy 编译器，介绍其中的增量 DOM 设计。&lt;/p&gt;
    
    </summary>
    
      <category term="Angular源码" scheme="https://godbasin.github.io/categories/Angular%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="功能设计" scheme="https://godbasin.github.io/tags/%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>前端这几年--13.关于技术开发的职业发展</title>
    <link href="https://godbasin.github.io/2021/11/28/about-front-end-13/"/>
    <id>https://godbasin.github.io/2021/11/28/about-front-end-13/</id>
    <published>2021-11-28T06:05:03.000Z</published>
    <updated>2021-11-28T06:08:49.570Z</updated>
    
    <content type="html"><![CDATA[<p>日经贴：程序员的 35 岁是天花板吗？35 岁以上的程序员都在做些什么？技术开发的职业路线要怎么规划？</p><a id="more"></a><h2 id="技术开发的职业发展道路到底该怎么走？"><a href="#技术开发的职业发展道路到底该怎么走？" class="headerlink" title="技术开发的职业发展道路到底该怎么走？"></a>技术开发的职业发展道路到底该怎么走？</h2><p>现在的互联网团队虽然很多，但也有很多人在不断涌入这个行业，导致竞争日益激烈。对于很多企业来说，钱少能熬的年轻人似乎是更好的选择，因此程序员群体中也流传着“35 岁就会被淘汰”的说法。</p><p>曾经有一段时间，我遇到了一些比较难过的坎，于是认真学习了一些关于心理健康的知识，尝试好好调整自己。那时候便想，如今的社会发展和变化的速度太快，大多数事情都被要求“快速”、“高效”，未来很多人会选择进入企业打工而不是自己创业，各种精神上的压力都不小，焦虑和抑郁的情绪也逐渐变多，或许心理健康也会越来越受到重视，且被未来的社会高度依赖了。</p><p>焦虑和压力，如今成了当代快餐文化的赠品，技术开发也是如此。或许国外不少的程序员可以一直作为前线开发，而国内情况则不同，很多时候大家对于工作经验更多的技术开发的要求，不再满足于完成一线开发的工作，而是要求他给企业和团队带来更大的价值，比如做技术架构、技术管理、技术输出、影响力建设等等。</p><p>那么，面临这样的大背景，作为走在路上都会被人群淹没的普通开发，留给我们的机会又有哪些呢？</p><h3 id="技术开发的深度和广度"><a href="#技术开发的深度和广度" class="headerlink" title="技术开发的深度和广度"></a>技术开发的深度和广度</h3><p>很多技术开发在谈到职业规划的时候，都会考虑到一个点：技术的广度和深度到底哪个更重要更适合自己？</p><p>过去的我觉得，走深度还是广度，和一个人的喜好与规划有关系，比如，如果以后想当独立开发显然各种技术都要有所涉猎，如果想在某个技术领域扎根则应该要深挖。</p><p>我在之前的团队有接触过一些全栈开发，实际上不同领域的知识体系有差异，但大多数在工作中也做各自领域中比较普遍的事情（比如前端写页面调样式，后台写 CURD 逻辑），而全栈开发更是难有精力和心思去解决深入的问题。我也因为技术深度的原因来到了现在的团队，现在的业务场景的确已经是前端领域中复杂性排名很前的，慢慢发现其实再复杂问题，也都可以将其梳理并一一拆解，然后再逐个击破去解决。</p><p>追求技术广度，在工作中接触的技术领域会很多很杂，其挑战点在于是否可以对不同领域的技术知识进行足够的思考和归纳，找出不同技术的共通点以及各自的特点，并能选择合适的技术去解决不同的问题。追求技术深度，则需要在某个足够复杂的领域中，将其逐一拆解，逐一解决后，还能将新获得的知识再次归纳整合，优化在该领域的技术网络。</p><p>所以，我们常说开发的技术能力，其实更多时候是由各自的开发经验和项目经历决定，不管是广度还是深度，都有其可以出彩的地方，也有或许会让人觉得无趣的时候。而作为技术开发，唯一要避免的是 1 年的工作经验当 10 年用，这样即使工作了 10 年，也只是原地踏步。</p><p>而<a href="https://godbasin.github.io/2021/11/12/about-front-end-12/">上一篇</a>我有讲到关于开发的技术门槛，其实在大多数开发的工作中，往往被低估的能力不是技术能力，而是工作能力（如沟通能力、理解能力、复盘能力、表达能力等等），不管技术能力如何，工作能力会更加直接地影响到我们的工作效果。</p><h3 id="大公司的生存策略"><a href="#大公司的生存策略" class="headerlink" title="大公司的生存策略"></a>大公司的生存策略</h3><p>我有时候会思考，像如今所谓 BAT、TMDJ 这些比较大的公司，到底喜欢怎样的员工呢？</p><p>一开始，我认为他们不喜欢特立独行的员工，实际上也大多如此。大公司里有很多部门和团队，但不管在怎样的团队，除了某些情况下会遇到技术突破的场景，大多数时候对技术开发的要求都是“快速”实现产品/老板需求，此时“听话”的员工会更“配合”和“响应”这样的快速变更。</p><p>但光“努力”和“听话”这样的品质显然是不够的。我遇到过好几个自己还挺喜欢的开发，他们认真负责、好学努力，也十分听从组织安排，却常常被甩锅和嫌弃不够“机灵”而被打低考核/开除。在我看来，他们只是缺乏一些职场经验，不够“油滑”，不懂得拒绝和保护自己而已，并不存在所谓“不够机灵”的情况。</p><p>我见过很多团队在招人的时候，都喜欢说要招“聪明”的开发。我不喜欢用是否“聪明”这样的词语去描述其他人，我也不认为我们有资格去给别人贴这样的标签。</p><p>这样算来，大公司的团队对开发的要求，不仅需要“努力”和“听话”，还需要足够“机灵”和“聪明”。这其中甚至没有多少是与“技术能力”有关系的，当然前面我也有讲过，对于开发来说，技术能力已经属于必备能力了。</p><p>除此之外，<a href="https://godbasin.github.io/2021/10/10/about-front-end-11/">前面</a>我也有提到过，大多数大公司内的技术开发，相比真正做好一个产品，更多时候会更优先考虑自身晋级/考核的情况，常常会事与愿违地做一些未必最适合业务场景，但更适合拿出去讲（吹水）的技术方案。</p><h3 id="小团队的技术天花板"><a href="#小团队的技术天花板" class="headerlink" title="小团队的技术天花板"></a>小团队的技术天花板</h3><p>以前我觉得大团队很厉害，比如光前端开发就有一百多号人，肯定有不少的技术积累和沉淀，也能学到不少的东西。一般来说，复杂场景的业务才需要用到这么多某个领域的开发，实际上大团队对团队管理和氛围的要求更高，毕竟鸟儿大了什么林子都有。</p><p>我有时候也会想，是不是选一个好点的小团队问题就少一些了，不过大多数小团队在业务发展迅速的时候，最终都会演变成大团队，能将团队控制在小团队协作的情况不多。如果只想呆在小团队里，可能只有少量的垂直领域业务、发展平稳的业务，或者运气好的话，就不会被各种疯狂变动卷到。</p><p>小团队开发的好处，在于少了很多不必要的沟通和协作，工作效率会好很多。当然，其实这也跟团队和业务有密切的关系，比如团队人员是否频繁变更，业务方向是否来回反复，这些都和团队和业务管理方式有直接的关系。从职业发展方向来说，如果遇上团队快速发展，（如果你希望的话）小团队可以有更多的机会往技术管理方向走。</p><p>很多人都觉得小团队肯定有技术天花板，认为大团队的技术能力肯定更好，其实这没有必然的联系。</p><p>对于想往管理方向的开发来说，小团队可能的确只能管理较少的人（除非快速扩招），而大团队则可以继续往上升。对于一线开发来说，其实团队的大小对个人影响不是非常大，直接影响到个人体验的，大概除了工资待遇，便是工作氛围、加班情况、开发效率和节奏等等，而这些未必和团队的规模有直接的关系。</p><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>说了很多，不管是技术路线该往深度还是广度走，还是该去大团队还是小团队，似乎都没有最优解。实际上，做技术开发这一行的很多人都未必出于热爱，我们也经常见到有人辞职去创业、考公务员、做老师。</p><p>如果问我，我觉得不管是被行业淘汰了、或对行业失去热情了，还是浑浑噩噩地一直焦虑地工作着，或是有了新的方向。不管什么时候，都要摆正自己的心态，只要人还在，只要还愿意继续尝试，一切都可以重新开始。不用太在意当前的状况，也不用着急和其他人比较，我们的人生还有很长的路在走，还有无数的机会让它变得有趣而精彩。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日经贴：程序员的 35 岁是天花板吗？35 岁以上的程序员都在做些什么？技术开发的职业路线要怎么规划？&lt;/p&gt;
    
    </summary>
    
      <category term="工作这杯茶" scheme="https://godbasin.github.io/categories/%E5%B7%A5%E4%BD%9C%E8%BF%99%E6%9D%AF%E8%8C%B6/"/>
    
    
      <category term="分享" scheme="https://godbasin.github.io/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>Angular框架解读--Ivy编译器之AOT/JIT</title>
    <link href="https://godbasin.github.io/2021/11/21/angular-design-ivy-4-aot-jit/"/>
    <id>https://godbasin.github.io/2021/11/21/angular-design-ivy-4-aot-jit/</id>
    <published>2021-11-21T07:18:34.000Z</published>
    <updated>2021-11-21T07:21:17.040Z</updated>
    
    <content type="html"><![CDATA[<p>作为“为大型前端项目”而设计的前端框架，Angular 其实有许多值得参考和学习的设计，本系列主要用于研究这些设计和功能的实现原理。本文主要介绍 Angular 中的 AOT 和 JIT 相关设计。</p><a id="more"></a><p>Angular 应用主要由组件及其 HTML 模板组成。由于浏览器无法直接理解 Angular 所提供的组件和模板，因此 Angular 应用程序需要先进行编译才能在浏览器中运行。</p><p>在 Angular 中，提供了两种方式编译 Angular 应用：</p><ul><li>即时编译 (JIT，Just in time)：它会在运行期间在浏览器中编译你的应用</li><li>预先编译（AOT，Ahead of Time）：它会在构建时编译你的应用和库</li></ul><h2 id="JIT"><a href="#JIT" class="headerlink" title="JIT"></a>JIT</h2><p>在 Angular 8 及更早版本中，默认情况下，在应用程序执行期间，将对模板进行编译，这便是 JIT 编译。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>JIT 编译相对 AOT 而言比较简单，核心逻辑在<code>JitCompiler</code>中。<code>JitCompiler</code>是 Angular 编译器的一个内部模块，它从组件类型开始，提取模板，并最终生成准备链接到应用程序的组件的编译版本。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> JitCompiler &#123;</span><br><span class="line">  <span class="comment">// 编译过程中的一些解析内容缓存</span></span><br><span class="line">  <span class="keyword">private</span> _compiledTemplateCache = <span class="keyword">new</span> Map&lt;Type, CompiledTemplate&gt;();</span><br><span class="line">  <span class="keyword">private</span> _compiledHostTemplateCache = <span class="keyword">new</span> Map&lt;Type, CompiledTemplate&gt;();</span><br><span class="line">  <span class="keyword">private</span> _compiledDirectiveWrapperCache = <span class="keyword">new</span> Map&lt;Type, Type&gt;();</span><br><span class="line">  <span class="keyword">private</span> _compiledNgModuleCache = <span class="keyword">new</span> Map&lt;Type, object&gt;();</span><br><span class="line">  <span class="keyword">private</span> _sharedStylesheetCount = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> _addedAotSummaries = <span class="keyword">new</span> Set&lt;<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">any</span>[]&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 模块编译相关方法</span></span><br><span class="line">  compileModuleSync(moduleType: Type): object &#123;&#125;</span><br><span class="line">  compileModuleAsync(moduleType: Type): <span class="built_in">Promise</span>&lt;object&gt; &#123;&#125;</span><br><span class="line">  compileModuleAndAllComponentsSync(</span><br><span class="line">    moduleType: Type</span><br><span class="line">  ): ModuleWithComponentFactories &#123;&#125;</span><br><span class="line">  compileModuleAndAllComponentsAsync(</span><br><span class="line">    moduleType: Type</span><br><span class="line">  ): <span class="built_in">Promise</span>&lt;ModuleWithComponentFactories&gt; &#123;&#125;</span><br><span class="line">  getComponentFactory(component: Type): object &#123;&#125;</span><br><span class="line">  loadAotSummaries(summaries: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">any</span>[]) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于运行时编译，Angular 会传递并编译所有模块，因此在编译模块过程中，还需要为所有嵌套模块加载声明的指令/管道。</p><p>实际上，在 JIT 中编译这些模块的过程中，需要依赖模块、组件、指令等装饰器的元数据，该过程在 AOT 中是构建时便完成了编译，在 JIT 中由于组件是动态加载和编译的，因此也需要在模板编译过程进行解析和维护。对装饰器中元数据的编译和管理，可参考<a href="https://godbasin.github.io/2021/03/27/angular-design-metadata/">《Angular 框架解读–元数据和装饰器》</a>一文。</p><h3 id="JIT-优势"><a href="#JIT-优势" class="headerlink" title="JIT 优势"></a>JIT 优势</h3><p>在运行时编译代码，这意味着它不会在构建时进行编译，而是在调用该组件时编译。JIT 在本地调试的情况下，会更有优势：</p><ol><li>在 JIT 模式下，并非所有代码都会在初始时间编译。只有在应用程序启动时需要的必要组件才会被编译，如果项目中需要某功能并且它不在已编译的代码中，才会编译该功能或组件。</li><li>JIT 有助于减轻 CPU 的负担，并使应用程序渲染速度更快。</li><li>使用 JIT 模式和映射文件编译代码，可以在检查模式下查看并链接到源代码。</li></ol><p>在执行时，Angular 编译器会将这些模板转换为 JavaScript 函数。在一个简单的应用程序中，JIT 编译将生成两个包：</p><ul><li>main.bundle.js : 63k (21k 缩小)</li><li>vendor.bundle.js : 3321k (960k 缩小)</li></ul><p>对<code>vendor.bundle.js</code>文件（使用<code>source-map-explorer</code>）的分析表明，Angular 编译器占总包大小的 35%。这种机制有两个缺点：</p><ol><li>JavaScript 包太重（显然是因为应用程序源需要在文件<code>vendor.bundle.js</code>中包含编译器）。</li><li>应用程序将在运行时编译模板，这会影响渲染时间。</li></ol><p>因此，Angular 提供了 AOT 编译，并在 Angular 9 及后续版本中将其设置为默认值。</p><h2 id="AOT"><a href="#AOT" class="headerlink" title="AOT"></a>AOT</h2><p>在浏览器下载和运行代码之前的编译阶段，Angular 预先（AOT）编译器会先把 Angular HTML 和 TypeScript 代码转换成高效的 JavaScript 代码。</p><h3 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h3><p>实际上，前面我们介绍的 Ivy 编译器中心智模型（参考<a href="https://godbasin.github.io/2021/11/06/angular-design-ivy-3-mental-model/">《Angular 框架解读–Ivy 编译器之心智模型》</a>），便是 AOT 的主要工作原理。主要包括：</p><ul><li>Angular AOT 编译器会提取元数据，来解释应由 Angular 管理的应用程序部分</li><li>通过在装饰器（例如<code>@Component()</code>）中显式指定元数据，也可以在被装饰的类的构造函数声明中隐式指定元数据</li><li>元数据告诉 Angular 要如何构造应用程序类的实例并在运行时与它们进行交互</li></ul><p>至于对装饰器中元数据的处理和编译过程，主要是通过将 Angular 编译集成到 TypeScript 编译器的编译流程中来实现。前面的<a href="https://godbasin.github.io/2021/08/15/angular-design-ivy-0-design/">Angular 框架解读–Ivy 编译器</a>系列文章有介绍，因此这里也不过多展开。</p><p>同样，我们可以找到<code>AotCompiler</code>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AotCompiler &#123;</span><br><span class="line">  <span class="keyword">private</span> _templateAstCache =</span><br><span class="line">      <span class="keyword">new</span> Map&lt;StaticSymbol, &#123;template: TemplateAst[], pipes: CompilePipeSummary[]&#125;&gt;();</span><br><span class="line">  <span class="keyword">private</span> _analyzedFiles = <span class="keyword">new</span> Map&lt;<span class="built_in">string</span>, NgAnalyzedFile&gt;();</span><br><span class="line">  <span class="keyword">private</span> _analyzedFilesForInjectables = <span class="keyword">new</span> Map&lt;<span class="built_in">string</span>, NgAnalyzedFileWithInjectables&gt;();</span><br><span class="line"></span><br><span class="line">  analyzeModulesSync(rootFiles: <span class="built_in">string</span>[]): NgAnalyzedModules &#123;&#125;</span><br><span class="line">  analyzeModulesAsync(rootFiles: <span class="built_in">string</span>[]): <span class="built_in">Promise</span>&lt;NgAnalyzedModules&gt; &#123;&#125;</span><br><span class="line">  findGeneratedFileNames(fileName: <span class="built_in">string</span>): <span class="built_in">string</span>[] &#123;&#125;</span><br><span class="line"></span><br><span class="line">  emitBasicStub(genFileName: <span class="built_in">string</span>, originalFileName?: <span class="built_in">string</span>): GeneratedFile &#123;&#125;</span><br><span class="line">  emitTypeCheckStub(genFileName: <span class="built_in">string</span>, originalFileName: <span class="built_in">string</span>): GeneratedFile|<span class="literal">null</span> &#123;&#125;</span><br><span class="line">  loadFilesAsync(fileNames: <span class="built_in">string</span>[], tsFiles: <span class="built_in">string</span>[]): <span class="built_in">Promise</span>&lt;</span><br><span class="line">      &#123;analyzedModules: NgAnalyzedModules, analyzedInjectables: NgAnalyzedFileWithInjectables[]&#125;&gt; &#123;&#125;</span><br><span class="line">  loadFilesSync(fileNames: <span class="built_in">string</span>[], tsFiles: <span class="built_in">string</span>[]):</span><br><span class="line">      &#123;analyzedModules: NgAnalyzedModules, analyzedInjectables: NgAnalyzedFileWithInjectables[]&#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line">  emitMessageBundle(analyzeResult: NgAnalyzedModules, locale: <span class="built_in">string</span>|<span class="literal">null</span>): MessageBundle &#123;&#125;</span><br><span class="line">  emitAllPartialModules2(files: NgAnalyzedFileWithInjectables[]): PartialModule[] &#123;&#125;</span><br><span class="line">  emitAllImpls(analyzeResult: NgAnalyzedModules): GeneratedFile[] &#123;&#125;</span><br><span class="line"></span><br><span class="line">  listLazyRoutes(entryRoute?: <span class="built_in">string</span>, analyzedModules?: NgAnalyzedModules): LazyRoute[] &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从对外提供的方法来看，相比于<code>JitCompiler</code>，显然<code>AotCompiler</code>并没有什么编译的过程，更多是解析文件并创建组件。两个<code>Compiler</code>相差很远，但我们可以找到同样包含的一个<code>_compileModule</code>来比较：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AotCompiler &#123;</span><br><span class="line">  <span class="keyword">private</span> _compileModule(outputCtx: OutputContext, ngModule: CompileNgModuleMetadata): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> providers: CompileProviderMetadata[] = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._options.locale) &#123;</span><br><span class="line">      <span class="keyword">const</span> normalizedLocale = <span class="keyword">this</span>._options.locale.replace(<span class="regexp">/_/g</span>, <span class="string">'-'</span>);</span><br><span class="line">      providers.push(&#123;</span><br><span class="line">        token: createTokenForExternalReference(<span class="keyword">this</span>.reflector, Identifiers.LOCALE_ID),</span><br><span class="line">        useValue: normalizedLocale,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._options.i18nFormat) &#123;</span><br><span class="line">      providers.push(&#123;</span><br><span class="line">        token: createTokenForExternalReference(<span class="keyword">this</span>.reflector, Identifiers.TRANSLATIONS_FORMAT),</span><br><span class="line">        useValue: <span class="keyword">this</span>._options.i18nFormat</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>._ngModuleCompiler.compile(outputCtx, ngModule, providers);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> JitCompiler &#123;</span><br><span class="line">  <span class="keyword">private</span> _compileModule(moduleType: Type): object &#123;</span><br><span class="line">    <span class="keyword">let</span> ngModuleFactory = <span class="keyword">this</span>._compiledNgModuleCache.get(moduleType)!;</span><br><span class="line">    <span class="keyword">if</span> (!ngModuleFactory) &#123;</span><br><span class="line">      <span class="keyword">const</span> moduleMeta = <span class="keyword">this</span>._metadataResolver.getNgModuleMetadata(moduleType)!;</span><br><span class="line">      <span class="keyword">const</span> extraProviders = <span class="keyword">this</span>.getExtraNgModuleProviders(moduleMeta.type.reference);</span><br><span class="line">      <span class="keyword">const</span> outputCtx = createOutputContext();</span><br><span class="line">      <span class="keyword">const</span> compileResult = <span class="keyword">this</span>._ngModuleCompiler.compile(outputCtx, moduleMeta, extraProviders);</span><br><span class="line">      ngModuleFactory = <span class="keyword">this</span>._interpretOrJit(</span><br><span class="line">          ngModuleJitUrl(moduleMeta), outputCtx.statements)[compileResult.ngModuleFactoryVar];</span><br><span class="line">      <span class="keyword">this</span>._compiledNgModuleCache.set(moduleMeta.type.reference, ngModuleFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ngModuleFactory;</span><br><span class="line">  &#125;</span><br><span class="line">|</span><br></pre></td></tr></table></figure><p>可以看到：</p><ul><li><code>AotCompiler</code>中更多是直接将作用域/上下文、元数据信息直接用于模块的创建，少了编译过程</li><li><code>JitCompiler</code>中会在运行时创建作用域、上下文，并通过编译过程获取需要的元数据，然后再进行模块的创建</li></ul><p>我们来分别看看 AOT 编译的三个阶段。</p><h3 id="AOT-编译阶段"><a href="#AOT-编译阶段" class="headerlink" title="AOT 编译阶段"></a>AOT 编译阶段</h3><p>AOT 编译分为三个阶段：</p><p><strong>一、代码分析。</strong>在此阶段，TypeScript 编译器和 AOT 收集器会创建源码的表现层。</p><p>TypeScript 编译器会做一些初步的分析工作，它会生成类型定义文件<code>.d.ts</code>，其中带有类型信息，Angular 编译器需要借助它们来生成代码：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> StaticSymbolResolverHost &#123;</span><br><span class="line">  <span class="comment">// 返回给定模块的 ModuleMetadata</span></span><br><span class="line">  <span class="comment">// Angular CLI 会在生成 .d.ts 文件并且模块导出变量或带有装饰器的类时为模块生成元数据</span></span><br><span class="line">  <span class="comment">// 模块元数据也可以通过在 tools/metadata 中使用 MetadataCollector 直接从 TypeScript 源生成</span></span><br><span class="line">  getMetadataFor(modulePath: <span class="built_in">string</span>): &#123; [key: <span class="built_in">string</span>]: <span class="built_in">any</span> &#125;[] | <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，AOT 收集器（<code>collector</code>）会记录 Angular 装饰器中的元数据，并把它们输出到<code>.metadata.json</code>文件（可以把<code>.metadata.json</code>文件看做一个包括全部装饰器的元数据的全景图）中，和每个<code>.d.ts</code>文件相对应：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 TypeScript 模块收集装饰器元数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> MetadataCollector &#123;</span><br><span class="line">  <span class="comment">// 返回一个 JSON.stringify 友好形式</span></span><br><span class="line">  <span class="comment">// 描述源文件中导出的类的装饰器，该类预期与模块相对应</span></span><br><span class="line">  <span class="keyword">public</span> getMetadata(</span><br><span class="line">    sourceFile: ts.SourceFile,</span><br><span class="line">    strict: <span class="built_in">boolean</span> = <span class="literal">false</span>,</span><br><span class="line">    substituteExpression?: (</span><br><span class="line">      value: MetadataValue,</span><br><span class="line">      node: ts.Node</span><br><span class="line">    ) =&gt; MetadataValue</span><br><span class="line">  ): ModuleMetadata | <span class="literal">undefined</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>收集器不会试图理解它收集并输出到<code>.metadata.json</code>中的元数据，它所能做的只是尽可能准确的表述这些元数据，并在检测到元数据中的语法违规时记录这些错误。解释这些<code>.metadata.json</code>是编译器在代码生成阶段要承担的工作。</p><p><strong>二、代码生成。</strong>在此阶段，编译器的<code>StaticReflector</code>会解释在 1 中收集的元数据，对元数据执行附加验证，如果检测到元数据违反了限制，则抛出错误。</p><p><code>StaticReflector</code>静态反射器实现了足够多的反射器 API，这是静态编译模板所必需的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> StaticReflector <span class="keyword">implements</span> CompileReflector &#123;</span><br><span class="line">  <span class="comment">// 元数据相关的静态符号缓存</span></span><br><span class="line">  <span class="keyword">private</span> annotationCache = <span class="keyword">new</span> Map&lt;StaticSymbol, <span class="built_in">any</span>[]&gt;();</span><br><span class="line">  <span class="keyword">private</span> shallowAnnotationCache = <span class="keyword">new</span> Map&lt;StaticSymbol, <span class="built_in">any</span>[]&gt;();</span><br><span class="line">  <span class="keyword">private</span> propertyCache = <span class="keyword">new</span> Map&lt;StaticSymbol, &#123; [key: <span class="built_in">string</span>]: <span class="built_in">any</span>[] &#125;&gt;();</span><br><span class="line">  <span class="keyword">private</span> parameterCache = <span class="keyword">new</span> Map&lt;StaticSymbol, <span class="built_in">any</span>[]&gt;();</span><br><span class="line">  <span class="keyword">private</span> methodCache = <span class="keyword">new</span> Map&lt;StaticSymbol, &#123; [key: <span class="built_in">string</span>]: <span class="built_in">boolean</span> &#125;&gt;();</span><br><span class="line">  <span class="keyword">private</span> staticCache = <span class="keyword">new</span> Map&lt;StaticSymbol, <span class="built_in">string</span>[]&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解释元数据</span></span><br><span class="line">  componentModuleUrl(typeOrFunc: StaticSymbol): <span class="built_in">string</span> &#123;&#125;</span><br><span class="line">  resolveExternalReference(</span><br><span class="line">    ref: o.ExternalReference,</span><br><span class="line">    containingFile?: <span class="built_in">string</span></span><br><span class="line">  ): StaticSymbol &#123;&#125;</span><br><span class="line">  findDeclaration(</span><br><span class="line">    moduleUrl: <span class="built_in">string</span>,</span><br><span class="line">    name: <span class="built_in">string</span>,</span><br><span class="line">    containingFile?: <span class="built_in">string</span></span><br><span class="line">  ): StaticSymbol &#123;&#125;</span><br><span class="line">  tryFindDeclaration(</span><br><span class="line">    moduleUrl: <span class="built_in">string</span>,</span><br><span class="line">    name: <span class="built_in">string</span>,</span><br><span class="line">    containingFile?: <span class="built_in">string</span></span><br><span class="line">  ): StaticSymbol &#123;&#125;</span><br><span class="line">  findSymbolDeclaration(symbol: StaticSymbol): StaticSymbol &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 验证元数据</span></span><br><span class="line">  <span class="keyword">public</span> tryAnnotations(<span class="keyword">type</span>: StaticSymbol): <span class="built_in">any</span>[] &#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> annotations(<span class="keyword">type</span>: StaticSymbol): <span class="built_in">any</span>[] &#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> shallowAnnotations(<span class="keyword">type</span>: StaticSymbol): <span class="built_in">any</span>[] &#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> propMetadata(<span class="keyword">type</span>: StaticSymbol): &#123; [key: <span class="built_in">string</span>]: <span class="built_in">any</span>[] &#125; &#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> parameters(<span class="keyword">type</span>: StaticSymbol): <span class="built_in">any</span>[] &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器理解收集器支持的所有语法形式，但是它也可能拒绝那些虽然语法正确但语义违反了编译器规则的元数据。</p><p><strong>三、模板类型检查。</strong>在此可选阶段，Angular 模板编译器使用 TypeScript 编译器来验证模板中的绑定表达式。</p><p>Angular 编译器最有用的功能之一就是能够对模板中的表达式进行类型检查，在由于出错而导致运行时崩溃之前就捕获任何错误。在模板类型检查阶段，Angular 模板编译器会使用 TypeScript 编译器来验证模板中的绑定表达式。</p><p>当模板绑定表达式中检测到类型错误时，进行模板验证时就会生成错误。这和 TypeScript 编译器在处理<code>.ts</code>文件中的代码时报告错误很相似。</p><h3 id="AOT-的优势"><a href="#AOT-的优势" class="headerlink" title="AOT 的优势"></a>AOT 的优势</h3><p>显然，使用 AOT 编译有这些好处：</p><ol><li>更快的渲染：借助 AOT，浏览器可以下载应用的预编译版本。浏览器加载的是可执行代码，因此它可以立即渲染应用，而无需等待先编译好应用。</li><li>更少的异步请求：编译器会在应用 JavaScript 中内联外部 HTML 模板和 CSS 样式表，从而消除了对那些源文件的单独 ajax 请求。</li><li>较小的 Angular 框架下载大小：如果已编译应用程序，则无需下载 Angular 编译器。编译器大约是 Angular 本身的一半，因此省略编译器会大大减少应用程序的有效载荷。</li><li>尽早检测模板错误：AOT 编译器会在构建步骤中检测并报告模板绑定错误，然后用户才能看到它们。</li><li>更高的安全性：AOT 在将 HTML 模板和组件提供给客户端之前就将其编译为 JavaScript 文件。没有要读取的模板，没有潜藏风险的客户端 HTML 或 JavaScript eval，受到注入攻击的机会就更少了。</li></ol><p>在 AOT 模式下，生成的包不再包含 HTML 模板，而是直接包含已编译的模板。如果检查由构建生成的文件<code>main.bundle.js</code>，会发现包含已编译模板的代码部分。</p><p>在同一个应用程序中，AOT 编译生成以下包：</p><ul><li>main.bundle.js : 59k (27k 缩小)</li><li>vendor.bundle.js：2281k（610k 缩小）</li></ul><p>可以看到，<code>vendor.bundle.js</code>的大小大大减少，因为它不再包含编译器。这种编译的优点很明显：减少应用程序负载、更少的请求、快速渲染。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>本文介绍了 Angular 中的 JIT/AOT 编译过程和工作原理，看起来似乎这些都和 Ivy 编译器关系不大。实际上，要实现 JIT、AOT 编译，核心便是 Ivy 编译器。在 View Engine 中虽然也有 JIT/AOT 的两种模式，但不管是装饰器元数据的解析，还是模板编译过程中的类型错误检查，在 Ivy 编译器的设计里都有非常大的区别。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://angular.cn/guide/aot-compiler" target="_blank" rel="noopener">预先（AOT）编译器</a></li><li><a href="https://medium.com/@kadrimoujib/angular-jit-vs-aot-15e211d94966" target="_blank" rel="noopener">Angular JiT vs AoT</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为“为大型前端项目”而设计的前端框架，Angular 其实有许多值得参考和学习的设计，本系列主要用于研究这些设计和功能的实现原理。本文主要介绍 Angular 中的 AOT 和 JIT 相关设计。&lt;/p&gt;
    
    </summary>
    
      <category term="Angular源码" scheme="https://godbasin.github.io/categories/Angular%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="功能设计" scheme="https://godbasin.github.io/tags/%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>前端这几年--12.技术开发的门槛高吗</title>
    <link href="https://godbasin.github.io/2021/11/12/about-front-end-12/"/>
    <id>https://godbasin.github.io/2021/11/12/about-front-end-12/</id>
    <published>2021-11-12T13:35:32.000Z</published>
    <updated>2021-11-12T13:36:38.252Z</updated>
    
    <content type="html"><![CDATA[<p>最近对程序员这个职业产生了一些困惑，所以一个问题一个问题地记录下来叭~</p><a id="more"></a><h2 id="技术开发到底是门槛低还是高？"><a href="#技术开发到底是门槛低还是高？" class="headerlink" title="技术开发到底是门槛低还是高？"></a>技术开发到底是门槛低还是高？</h2><p>对于“程序员”这个职业，或许现在已经被大多数人认知，常常被认为是吃技术饭碗、工资高的一个工种。正所谓内行看门道外行看热闹，这两个标签都只能代表一部分开发。</p><p>有工资高的，自然就有工资低的。资本的本质就是商业化，通俗来说就是赚钱，因此只要存在可优化和压缩的可能性，都会被优化，而目前的技术开发大多数服务于资本。</p><h3 id="技术开发与研发"><a href="#技术开发与研发" class="headerlink" title="技术开发与研发"></a>技术开发与研发</h3><p>实际上，我们常常将“研发”和“开发”搞混。根据维基百科，研发并非旨在立即产生利润，而且通常具有更大的风险和不确定的投资回报。如今大多数互联网产品“研发”会对投入产出比要求更高，也会对盈利预期有所要求，讲究“快速试错”、“快速迭代”，对产品生命周期、准确来说是盈利周期，会有更高的要求，这个不行就撤了做下一个。</p><p><a href="https://en.wikipedia.org/wiki/Research_and_development" target="_blank" rel="noopener">维基百科</a>：</p><blockquote><p>新产品的设计和开发往往是公司生存的关键因素。在瞬息万变的全球工业格局中，公司必须不断修改其设计和产品范围。由于激烈的竞争和消费者不断变化的偏好，这也是必要的。如果没有研发计划，公司就必须依靠战略联盟、收购和网络来利用他人的创新。</p></blockquote><p>显然，如今很多大公司更倾向于后者，因为相比预期不确定的产品研发，这种方式可以更稳定地盈利。因此我们也常常会看到，愿意长期投入而不计成本地进行研发的团队很少，因为研发需要资金，更多时候都是通过融资、战略合作来解决资金问题。但这样依然会存在问题，投资方对盈利的预期，是否和产品本身能够匹配。</p><p>所以，很多时候我们提到“程序员”，其实大多数都属于开发而非研发。至于做开发是不是一个技术活，说实话，这玩意入门不难，但是做好不易。</p><h3 id="自学入门与培训班的红海"><a href="#自学入门与培训班的红海" class="headerlink" title="自学入门与培训班的红海"></a>自学入门与培训班的红海</h3><p>正因为入门不难，所以这些年我们也能看到无数培训班的出现。当然，培训效果显然不像宣传那么好，但对于一些对这个行业一概不知的人来说，有人引路和所谓培训是更快捷的方式。</p><p>培训班里做的事情，就是将一些网上的文章/博客/课程资源进行整合，然后按照课时整理成每节课/每天的计划，最重要的一点是，他们会针对面试的知识点做较多的培训，也会教学员简历该怎么写。（其实我没怎么了解过培训班，以上是我自己认为一个培训班应该会做的一些事情）。所以，对于知道如何获取资源的小白来说，自学入门也是可以做到的。</p><p>很多培训班都会有一些成功案例，多少人拿到了 offer，甚至如果有人进了大公司肯定都得上历史荣耀板了（如果有这么一个板的话）。这些成功案例的确能说明一些事情：这个培训班针对面试的知识体系准备/简历包装比较到位，但实际上开始工作之后，能拿到怎样的表现都只能靠自己了。</p><p>其实我觉得培训班里最需要教的一件事，就是要怎么通过搜索引擎，使用合适的关键字，找到有效的问题解决方法。因为在大多数开发的工作中遇到的问题，99% 都可以在网上找到办法解决，至于剩下的 1%，只需要重启 VsCode/App/浏览器/电脑，就可以解决。所以，对自学入门的开发来说，搜索也是直接影响工作能力和效率的一种能力。</p><h3 id="晋级-考核与技术能力的关系"><a href="#晋级-考核与技术能力的关系" class="headerlink" title="晋级/考核与技术能力的关系"></a>晋级/考核与技术能力的关系</h3><p>对于开发来说，职级则常常被认为是技术能力的标签。</p><p>不管是面试/找工作，还是开发与开发之间的交流，通常都会问到职级。什么阿里 P7/P8、腾讯 T10/T11，还有其他公司的（抱歉这块了解得不多），职级一般会与薪酬待遇挂钩，也会被动与开发的技术能力挂钩，所以晋级对开发来说是一件大事情。同样，考核也会和年终奖/待遇挂钩，因此也是开发中的大事情。拿到一个好的考核，顺利通过晋级答辩，可能就是互联网打工人比较开心的事情了。</p><p>或许有些人会认为，职级高的人肯定技术能力比较厉害，实际上也未必都是这样的。</p><p>我在工作中经历过两次晋级答辩，而唯一让我觉得自己能通过的原因，结论是只是运气好罢了。要怎么理解“运气好”这件事呢？大概就是你恰好在答辩前拿到了一个“容易答辩”的项目，然后做的结果还不错，答辩过程中恰好评委也认为有价值/做得不错，就通过了。</p><p>除此以外，老生常谈的 KPI 项目反而到处都是，很多人为了答辩而故意做一些项目（将原本简单的场景搞得很复杂、用高大上的术语包装等等），答辩通过后就甩手不管、让其他人维护，继续做下一个可以用来下次答辩的项目，这样的事情每天都在开发的世界里上演。还有所谓 PPT 工程，有些人没有做出成果甚至还没开始做的项目，只拿一个包装得很好的 PPT 去答辩并且通过了。正因为答辩通过并没有一个固定的标准，因此评委的主观态度占了很大的比例，我甚至见过为了提高答辩通过率，专门组队去找到相关评委的课上刷脸获取好感的。</p><p>考核也是如此，考核更多时候是直接上级进行评分排名，因此给上级们留下一个好的印象便很重要，也因此产生了不少的对上管理手段，比如刷脸刷存在感，迎合上级的想法做事情，等等。也常常会产生所谓的嫡系，这个词我也是工作好几年之后才知道的，虽然我个人认为，把自己的事情做好就可以，不需要过度做一些迎合的事情，但实际上这样的事情也每天都会在身边上演，而我能做的也只有管好我自己。</p><p>也有人说，不管是晋级也好，考核也好，都属于管理工具。从这个角度来说，晋级/考核与技术能力并没有必然的关系，新人可以将功能实现得很漂亮，高职级的开发也可能写出糟糕的代码。</p><p>我见过很多技术能力一般但晋级/考核很不错的例子，以及很多责任心和敬畏之心都差强人意的人甚至都过得很不错。当然这没有高低对错之分，但这样一来，对我来说职级和考核也并不那么重要了，因为它并不能代表你的技术能力，也不能代表你的实际能力。再者，自身的价值没有被团队挖掘和发现，其实这个团队也未必适合自己。</p><h3 id="工作能力与技术能力的差别"><a href="#工作能力与技术能力的差别" class="headerlink" title="工作能力与技术能力的差别"></a>工作能力与技术能力的差别</h3><p>前面提到，个人认为不管是考核还是职级，都跟自身的技术能力没有确定的关系，那么它会跟什么有关系呢？我认为是工作能力。</p><p>工作能力这个词很笼统，实际上它揽扩了所有工作中需要的一些能力。对于开发来说，或许技术能力是工作能力的一部分，但实际上更多的时候，我们的工作中都对沟通能力、理解能力、复盘能力（天知道为什么我要将其称作一种能力）、表达能力、情绪能力（感受他人情绪/管理自身情绪）等等各式各样的职场能力同样有一定的要求。</p><p>回到本文的主题：技术开发的门槛有多高？</p><p>大多数情况下，团队对技术开发的要求主要是：能快速响应团队需求，高效高质量解决团队问题。个人认为，对于大多数的产品开发过程中，技术能力只占据了一部分，且要求的门槛也并不会很高，尤其在一些团队急速扩招时还会降低招聘门槛。</p><p>作为技术开发，大多数时候我们都是谷歌工程师。对于新人来说，遇到奇怪的报错就去谷歌搜索一下解决方案，遇到没听过的东西就去谷歌搜索一下介绍和说明；对于有一定工作经验的开发来说，工作中常常要参考和学习业界方案、研究竞品方案，然后根据自己的项目情况，选择合适的解决方案并将其进行落地。</p><p>要把一个项目做成，从项目初期各种沟通和收集信息（沟通能力和理解能力），项目开始前的方案设计和评审（技术能力和表达能力），项目过程中的开发/联调/测试/问题修复（技术能力、沟通能力、表达能力和情绪能力），项目后期的复盘总结（复盘能力、表达能力），这个过程中除了技术能力也同样涉及到各式各样的职场能力，这中间的某一个短板可能就成了你的最大瓶颈，甚至可能因为某一处没有做好而背了低考核。</p><p>因此，<strong>与其说大多数的开发工作中对技术能力的要求门槛不高，还不如说对于“本该就拥有技术能力”这样的开发群体，更多时候技术以外的其他能力更能直接影响他的工作表现</strong>。</p><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>很久以前， 我选择做开发的其中一个原因，便是觉得开发应该是一个比较单纯简单的群体，同时工作性质对逻辑要求比较高，这样的人肯定也很讲道理。因为抱着这样幼稚的想法，曾在工作中遇到了许多不愉快的经历。当然这不是谁的问题，只要有利益纠纷的地方，必然都有人情世故。</p><p>我常常在想，如果是“研发”岗位而不是“开发”岗位，是不是就没有这么多的问题呢？今晚做个梦试试看。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近对程序员这个职业产生了一些困惑，所以一个问题一个问题地记录下来叭~&lt;/p&gt;
    
    </summary>
    
      <category term="工作这杯茶" scheme="https://godbasin.github.io/categories/%E5%B7%A5%E4%BD%9C%E8%BF%99%E6%9D%AF%E8%8C%B6/"/>
    
    
      <category term="分享" scheme="https://godbasin.github.io/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>Angular框架解读--Ivy编译器之心智模型</title>
    <link href="https://godbasin.github.io/2021/11/06/angular-design-ivy-3-mental-model/"/>
    <id>https://godbasin.github.io/2021/11/06/angular-design-ivy-3-mental-model/</id>
    <published>2021-11-06T06:50:23.000Z</published>
    <updated>2021-11-06T06:54:13.843Z</updated>
    
    <content type="html"><![CDATA[<p>作为“为大型前端项目”而设计的前端框架，Angular 其实有许多值得参考和学习的设计，本系列主要用于研究这些设计和功能的实现原理。本文围绕 Angular 的核心功能 Ivy 编译器，介绍其中 Ivy 的心智模型。</p><a id="more"></a><p>上一篇<a href="https://godbasin.github.io/2021/10/31/angular-design-ivy-2-cli-compiler/">Angular 框架解读–Ivy 编译器之 CLI 编译器</a>中，我们介绍了 Angular 基于 TypeScript 的<code>tsc</code>编译能力之上，实现了 Angular 本身的一些特性能力，包括支持模板的类型检查、将文件和模块依赖关系生成到<code>d.ts</code>文件中，等等。</p><p>这部分的内容主要从 CLI 脚手架层面的编译出发，介绍在 Angular 中如何通过编译器处理代码的编译过程。本文我们主要关注 Angular 的模板编译过程，具体到装饰器的编译过程等。</p><h2 id="View-Engine"><a href="#View-Engine" class="headerlink" title="View Engine"></a>View Engine</h2><p>在 View Engine 中，编译器执行整个程序分析并生成模板和注入器定义，这些定义使用此全局知识来扁平化注入器作用域定义、将指令内联到组件中、预计算查询、预计算内容投影等。全局知识要求在编译模块时生成模块和组件工厂作为最后的全局步骤。如果任何传递信息发生变化，则需要重新生成所有工厂。</p><p>单独的组件和模块编译仅在模块定义级别和源代码中受支持。也就是说，npm 包必须包含生成工厂所需的元数据，它们本身不能包含生成的工厂。这是因为如果它们的任何依赖项发生变化，它们的工厂将无效，从而阻止它们在其依赖项中使用版本范围。</p><p>在源代码中，Angular 将 View Engine 的这种代码生成风格称为 Renderer2，当我们看到 render2 相关的代码，便是 View Engine 相关实现。相对的，当我们看到 render3 相关的代码，便是 Ivy 编译器的相关实现。</p><h2 id="Ivy-模板编译"><a href="#Ivy-模板编译" class="headerlink" title="Ivy 模板编译"></a>Ivy 模板编译</h2><p>在前面<a href="https://godbasin.github.io/2021/08/15/angular-design-ivy-0-design/">Angular 框架解读–Ivy 编译器整体设计</a>一文中，我有大概介绍 Ivy 编译的大概过程，包括：</p><ol><li>标记模板。</li><li>将标记内容解析为 HTML AST。</li><li>将 HTML AST 转换为 Angular 模板 AST。</li><li>将 Angular 模板 AST 转换为模板函数。</li></ol><p>前面提到，View Engine 中编译器生成模板和注入器时依赖全局知识，因此工厂是在构建最终应用程序时生成的。</p><p>Ivy 模板编译可以从字符串生成模板函数，而无需附加信息。但是，该字符串的正确解释需要选择器范围。选择器作用域是在运行时构建的（参考<a href="https://godbasin.github.io/2021/09/19/angular-design-ivy-1-view-data-and-node-injector/">《Angular 框架解读–Ivy 编译器的视图数据和依赖解析》</a>），允许运行时使用仅从字符串构建的函数，只要给它一个在实例化期间使用的选择器作用域（例如<code>NgModule</code>）。</p><h3 id="Ivy-心智模型"><a href="#Ivy-心智模型" class="headerlink" title="Ivy 心智模型"></a>Ivy 心智模型</h3><p>在 Ivy 中，运行时的设计允许单独编译，通过在运行时执行之前由编译器预先计算的大部分内容。这允许更改组件的定义，而无需重新编译依赖于它们的模块和组件。</p><p><strong>Ivy 的心智模型是：装饰器就是编译器。</strong></p><p>也就是说，装饰器可以被认为是类转换器的参数，该类转换器通过基于装饰器参数生成定义来转换类：</p><ul><li><code>@Component</code>装饰器通过添加<code>ɵcmp</code>静态属性来转换类</li><li><code>@Directive</code>添加<code>ɵdir</code></li><li><code>@Pipe</code>添加<code>ɵpipe</code>等</li></ul><p>在大多数情况下，提供给装饰器的值足以生成定义。但是，在解释模板的情况下，编译器需要知道为模板范围内的每个组件、指令和管道定义的选择器。</p><p>前面我们说过，Ivy 编译模型是将 Angular 装饰器（<code>@Injectable</code>等）编译为类 (<code>ɵprov</code>) 上的静态属性。此操作必须在没有全局程序知识的情况下进行，并且在大多数情况下仅需要知道该单个装饰器。因此在 Ivy 中，每个将单个装饰器转换为静态字段的“编译器”都将充当“纯函数”。</p><p>对于这种情况，在 Angular 中可使用元数据来维护这些数据。给定有关特定类型和装饰器的输入元数据，它将生成一个对象，该对象描述要添加到该类型的字段，以及该字段的初始化值（采用 AST 格式）。</p><h3 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h3><p>前面我在<a href="https://godbasin.github.io/2021/03/27/angular-design-metadata/">《Angular 框架解读–元数据和装饰器》</a>一文中介绍了编译时从装饰器产生元数据的过程，而在<a href="https://godbasin.github.io/2021/10/31/angular-design-ivy-2-cli-compiler/">《Angular 框架解读–Ivy 编译器之 CLI 编译器》</a>一文中介绍了 Angular 通过修改了 TypeScript 编译过程，从而将 Angular 中模块和文件间的依赖关系保存在生成的<code>d.ts</code>。</p><p>Angular 会转换<code>.js</code>文件和<code>.d.ts</code>文件以反映 Angular 装饰器的内容，然后将其删除。除了在类型检查和引用反转期间，这种转换是逐个文件完成的，没有全局知识。</p><p>比如，这样一个<code>Component</code>文件：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, Input &#125; <span class="keyword">from</span> <span class="string">"@angular/core"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">"greet"</span>,</span><br><span class="line">  template: <span class="string">"&lt;div&gt; Hello, &#123;&#123;name&#125;&#125;! &lt;/div&gt;"</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> GreetComponent &#123;</span><br><span class="line">  <span class="meta">@Input</span>() name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经<code>ngtsc</code>编译后，会包括该组件的<code>.js</code>文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> i0 = <span class="built_in">require</span>(<span class="string">"@angular/core"</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetComponent</span> </span>&#123;&#125;</span><br><span class="line">GreetComponent.ɵcmp = i0.ɵɵdefineComponent(&#123;</span><br><span class="line">  type: GreetComponent,</span><br><span class="line">  tag: <span class="string">"greet"</span>,</span><br><span class="line">  factory: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> GreetComponent(),</span><br><span class="line">  template: <span class="function"><span class="keyword">function</span> (<span class="params">rf, ctx</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rf &amp; RenderFlags.Create) &#123;</span><br><span class="line">      i0.ɵɵelementStart(<span class="number">0</span>, <span class="string">"div"</span>);</span><br><span class="line">      i0.ɵɵtext(<span class="number">1</span>);</span><br><span class="line">      i0.ɵɵelementEnd();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rf &amp; RenderFlags.Update) &#123;</span><br><span class="line">      i0.ɵɵadvance(<span class="number">1</span>);</span><br><span class="line">      i0.ɵɵtextInterpolate1(<span class="string">"Hello "</span>, ctx.name, <span class="string">"!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>以及带有装饰器元数据信息的<code>.d.ts</code>文件：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> i0 <span class="keyword">from</span> <span class="string">"@angular/core"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> GreetComponent &#123;</span><br><span class="line">  <span class="keyword">static</span> ɵcmp: i0.NgComponentDef&lt;GreetComponent, <span class="string">"greet"</span>, &#123; input: <span class="string">"input"</span> &#125;&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用反转和类型检查所需的信息包含在<code>.d.ts</code>中<code>ɵcmp</code>的类型声明中。</p><h3 id="NPM-上现有代码的兼容"><a href="#NPM-上现有代码的兼容" class="headerlink" title="NPM 上现有代码的兼容"></a>NPM 上现有代码的兼容</h3><p>如今存在于 NPM 上的 Angular 库以 Angular 包的格式分发，其中详细说明了所交付的工件，包括 ES2015 和 ESM（ES5 + ES2015 模块）风格的已编译<code>.js</code>文件、<code>.d.ts</code>文件和<code>.metadata.json</code>文件。其中，<code>.js</code>文件删除了 Angular 装饰器信息，而<code>.metadata.json</code>文件以替代格式保留装饰器元数据。</p><p>我们已经知道，在 Ivy 中，在工厂中生成的信息现在在 Angular 中作为定义生成，在 Angular 装饰类中作为静态字段生成。View Engine(Renderer2) 要求在构建最终应用程序时，还要生成所有库的所有工厂。在 Ivy 中，定义是在编译库时生成的。</p><p>Ivy 编译可以通过为它们生成工厂、并在运行时将静态属性回补到类中来适应 View Engine 目标库。比如：</p><ul><li>当应用程序包含 View Engine 目标库时，Ivy 定义需要回补到组件、指令、模块、管道和可注入类</li><li>可以在生成它的同一位置生成<code>NgModuleFactory</code>的实现，<code>NgModuleFactory</code>的这个实现将在通过调用函数创建第一个模块实例时，对 View Engine 样式类进行回补丁</li></ul><p>同样的，Ivy 编译后的产物与 View Engine 的不同之处在于声明包含在生成的输出中，并且应该包含在发布到 npm 的包中。</p><p>因此，编译后的产物仍然需要包含<code>.metadata.json</code>文件，它们会按如下所述进行转换：</p><ul><li>当编译器向类添加声明时，它也会转换<code>.metadata.json</code>文件以反映添加到类中的新静态字段</li><li>一旦将静态字段添加到元数据中，Ivy 编译器就不再需要装饰器中的信息</li></ul><h3 id="转换元数据"><a href="#转换元数据" class="headerlink" title="转换元数据"></a>转换元数据</h3><p>View Engine 中使用<code>.metadata.json</code>文件来存储直接从<code>.ts</code>文件推断的信息，并包含 TypeScript 生成的<code>.d.ts</code>文件中未包含的值信息。</p><p>Ivy 中，某个类的元数据被转换为 Ivy 编译器生成的转换后的<code>.js</code>文件的元数据。</p><p>例如，一个组件的<code>@Component</code>被编译器删除并替换为<code>ɵcmp</code>，<code>.metadata.json</code>文件也进行了类似的转换，但省略了分配值的内容（例如<code>“ɵcmp”：{}</code>）。 编译器不记录为组件声明的选择器，但需要生成<code>ngModuleScope</code>以便记录信息。构建所需的信息需要<code>ngModuleScope</code>从指令和管道传送到声明它们的模块。</p><p><code>@Component</code>组件的元数据通过以下方式转换：</p><ol><li>删除<code>@Component</code>指令。</li><li>添加<code>&quot;ɵcmp&quot;: {}</code>静态字段。</li><li>添加<code>&quot;ngSelector&quot;: &lt;selector-value&gt;</code>静态字段。</li></ol><p>比如以下例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// my.component.ts</span></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">"my-comp"</span>,</span><br><span class="line">  template: <span class="string">`&lt;h1&gt;Hello, &#123;&#123; name &#125;&#125;!&lt;/h1&gt;`</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> MyComponent &#123;</span><br><span class="line">  <span class="meta">@Input</span>() name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会生成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// my.component.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> </span>&#123;</span><br><span class="line">  name: string;</span><br><span class="line">  <span class="keyword">static</span> ɵcmp = ɵɵdefineComponent(&#123;...&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及元数据信息：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"__symbolic"</span>: <span class="string">"module"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="number">4</span>,</span><br><span class="line">  <span class="attr">"metadata"</span>: &#123;</span><br><span class="line">    <span class="attr">"MyComponent"</span>: &#123;</span><br><span class="line">      <span class="attr">"__symbolic"</span>: <span class="string">"class"</span>,</span><br><span class="line">      <span class="attr">"statics"</span>: &#123;</span><br><span class="line">        <span class="attr">"ɵcmp"</span>: &#123;&#125;,</span><br><span class="line">        <span class="attr">"ngSelector"</span>: <span class="string">"my-comp"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，<code>@Directive</code>、<code>@Pipe</code>等其他装饰器也是相类似的处理，这里不多介绍。</p><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>Angular 的设计真的是太多太多啦，研究了好久还没研究到具体编译的地方，不过讲到目前这里，其实我们已经对 Ivy 编译器的整体情况有个大概的了解，包括基于 Ivy 编译模型下的组件、指令、管道等装饰器的编译过程和产物，以及它与 View Engine 更优的地方、兼容的处理。</p><p>而关于 Ivy 中的变更检测、AOT/JIT、Tree-shaking 等内容，会在后面继续研究分析~</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://github.com/angular/angular/blob/master/packages/compiler/design/architecture.md" target="_blank" rel="noopener">DESIGN DOC(Ivy): Compiler Architecture</a></li><li><a href="https://github.com/angular/angular/blob/master/packages/compiler/design/separate_compilation.md" target="_blank" rel="noopener">DESIGN DOC (Ivy): Separate Compilation</a></li><li><a href="https://indepth.dev/posts/1062/ivy-engine-in-angular-first-in-depth-look-at-compilation-runtime-and-change-detection" target="_blank" rel="noopener">Ivy engine in Angular: first in-depth look at compilation, runtime and change detection</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为“为大型前端项目”而设计的前端框架，Angular 其实有许多值得参考和学习的设计，本系列主要用于研究这些设计和功能的实现原理。本文围绕 Angular 的核心功能 Ivy 编译器，介绍其中 Ivy 的心智模型。&lt;/p&gt;
    
    </summary>
    
      <category term="Angular源码" scheme="https://godbasin.github.io/categories/Angular%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="功能设计" scheme="https://godbasin.github.io/tags/%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Angular框架解读--Ivy编译器之CLI编译器</title>
    <link href="https://godbasin.github.io/2021/10/31/angular-design-ivy-2-cli-compiler/"/>
    <id>https://godbasin.github.io/2021/10/31/angular-design-ivy-2-cli-compiler/</id>
    <published>2021-10-31T03:01:12.000Z</published>
    <updated>2021-10-31T03:20:48.768Z</updated>
    
    <content type="html"><![CDATA[<p>作为“为大型前端项目”而设计的前端框架，Angular 其实有许多值得参考和学习的设计，本系列主要用于研究这些设计和功能的实现原理。本文围绕 Angular 的核心功能 Ivy 编译器，介绍其中CLI层面的编译器编译过程。</p><a id="more"></a><p>在 Angular 中实现了自己的编译器，来处理 TypeScript 编译器无法完全做到的一些事情。在 Ivy 编译器中，这部分的能力又做了进一步的提升，比如模板类型检查、模块依赖解析等等。</p><h2 id="Ivy-编译器"><a href="#Ivy-编译器" class="headerlink" title="Ivy 编译器"></a>Ivy 编译器</h2><p>在前面<a href="https://godbasin.github.io/2021/08/15/angular-design-ivy-0-design/">Angular 框架解读–Ivy 编译器整体设计</a>一文中，我有介绍 Ivy 编译器主要包括两部分：</p><ol><li><code>ngtsc</code>：作为主要的 Ivy 编译器，将 Angular 装饰器化为静态属性。</li><li><code>ngcc</code>：作为兼容性的 Ivy 编译器，主要负责处理来自 NPM 的代码并生成等效的 Ivy 版本。</li></ol><p>本文将会主要围绕<code>ngtsc</code>该编译器进行介绍。</p><h3 id="Angular-中的-AST-解析"><a href="#Angular-中的-AST-解析" class="headerlink" title="Angular 中的 AST 解析"></a>Angular 中的 AST 解析</h3><p>要实现 AST 的解析和转换，离不开解析器。对于 Typescript 代码来说，编译器的整体流程为：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">                                                                |<span class="string">------------</span>|</span><br><span class="line">                           |<span class="string">----------------------------------&gt; </span>|<span class="string"> TypeScript </span>|</span><br><span class="line">                           |<span class="string">                                    </span>|<span class="string">   .d.ts    </span>|</span><br><span class="line">                           |<span class="string">                                    </span>|<span class="string">------------</span>|</span><br><span class="line">                           |</span><br><span class="line">|<span class="string">------------</span>|<span class="string">          </span>|<span class="string">-----</span>|<span class="string">               </span>|<span class="string">-----</span>|<span class="string">           </span>|<span class="string">------------</span>|</span><br><span class="line">|<span class="string"> TypeScript </span>|<span class="string"> -parse-&gt; </span>|<span class="string"> AST </span>|<span class="string"> -&gt;transform-&gt; </span>|<span class="string"> AST </span>|<span class="string"> -&gt;print-&gt; </span>|<span class="string"> JavaScript </span>|</span><br><span class="line">|<span class="string">   source   </span>|<span class="string">    </span>|<span class="string">     </span>|<span class="string">-----</span>|<span class="string">       </span>|<span class="string">       </span>|<span class="string">-----</span>|<span class="string">           </span>|<span class="string">   source   </span>|</span><br><span class="line">|<span class="string">------------</span>|<span class="string">    </span>|<span class="string">        </span>|<span class="string">          </span>|<span class="string">                         </span>|<span class="string">------------</span>|</span><br><span class="line">                  |<span class="string">    type-check     </span>|</span><br><span class="line">                  |<span class="string">        </span>|<span class="string">          </span>|</span><br><span class="line">                  |<span class="string">        v          </span>|</span><br><span class="line">                  |<span class="string">    </span>|<span class="string">--------</span>|<span class="string">     </span>|</span><br><span class="line">                  |<span class="string">--&gt; </span>|<span class="string"> errors </span>|<span class="string"> &lt;---</span>|</span><br><span class="line">                       |<span class="string">--------</span>|</span><br></pre></td></tr></table></figure><p>该过程包括四个步骤：</p><ol><li>parse 解析：它是一个传统的递归下降解析器，稍微调整以支持增量解析，它发出一个抽象语法树 (AST)，有助于识别文件中导入了哪些文件。</li><li>type-check 类型检查器：类型检查器构建一个符号表，然后对文件中的每个表达式进行类型分析，报告它发现的错误。</li><li>transform 转换：转换步骤是一组 AST 到 AST 转换，它们执行各种任务，例如删除类型声明、将模块和类声明降低到 ES5、将异步方法转换为状态机等。</li><li>print 打印：TS 到 JS 的实际转换是整个过程中最昂贵的操作。</li></ol><p>在了解 Angular 是如何处理之前，我们需要知道，对 TypeScript 编译器 API 的任何使用都遵循一个多步骤过程，包括：</p><p><img src="https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/angular-design-ivy-2-ast-1.jpg" alt></p><ul><li>一个<code>ts.CompilerHost</code>被创建</li><li><code>ts.CompilerHost</code>加上一组“根文件”，用于创建<code>ts.Program</code>,<code>ts.Program</code>用于收集各种诊断（类型检查）</li><li><code>ts.Program</code>被要求<code>emit</code>，并生成 JavaScript 代码</li></ul><p>将 Angular 编译集成到此过程中的编译器遵循非常相似的流程，但有一些额外的步骤：</p><ul><li>一个<code>ts.CompilerHost</code>被创建</li><li><code>ts.CompilerHost</code>包含在<code>NgCompilerHost</code>中，它将 Angular 特定文件添加到编译中</li><li><code>ts.Program</code>是从<code>NgCompilerHost</code>及其增强的根文件集创建的</li><li>一个<code>CompilationTicket</code>被创建，可选择合并来自先前编译运行的任何状态</li><li><code>NgCompiler</code>是使用<code>CompilationTicket</code>创建的</li><li>诊断信息可以正常从<code>ts.Program</code>收集，也可以从<code>NgCompiler</code>收集</li><li>在发射之前，调用<code>NgCompiler.prepareEmit</code>以检索需要馈送到<code>ts.Program.emit</code>的 Angular 转换器</li><li>使用上面的 Angular 转换器在<code>ts.Program</code>上调用发射，它生成带有 Angular 扩展的 JavaScript 代码</li></ul><p>在这些 Angular 特定的步骤中，主要进行几件事：</p><p><img src="https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/angular-design-ivy-2-ast-2.jpg" alt></p><ol><li>会将特定于 Angular 的文件添加到编译过程中，比如<code>NgModele</code>、<code>Component</code>的解析。</li><li>修改生成的<code>d.ts</code>，来保存 Angular 中模块和文件间的依赖关系。</li><li>会增加 Angular 中的类型校验，包括<code>&lt;tmeplate&gt;</code>模板的类型校验。</li></ol><p>而在自定义 TypeScript 编译器中执行 Angular 编译，主要依赖于<code>NgCompiler</code>，我们来看一下核心的一些方法：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> NgCompiler &#123;</span><br><span class="line">  <span class="comment">// 将一个 CompilationTicket 转换为一个用于请求编译的 NgCompiler 实例</span></span><br><span class="line">  <span class="comment">// 根据编译请求的性质，NgCompiler 实例可能会从以前的编译中重用并随着任何更改进行更新</span></span><br><span class="line">  <span class="comment">// 它可能是一个新实例，它可以增量地重用以前编译中的状态，或者它可能代表一个完全新的编译 </span></span><br><span class="line">  <span class="keyword">static</span> fromTicket(ticket: CompilationTicket, adapter: NgCompilerAdapter, perfRecorder?: PerfRecorder) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取文件的资源依赖</span></span><br><span class="line">  getResourceDependencies(file: ts.SourceFile): <span class="built_in">string</span>[] &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取此编译的所有与 Angular 相关的诊断信息</span></span><br><span class="line">  getDiagnostics(): ts.Diagnostic[] &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 Angular.io 错误指南链接添加到此编译的诊断中</span></span><br><span class="line">  <span class="keyword">private</span> addMessageTextDetails(diagnostics: ts.Diagnostic[]): ts.Diagnostic[] &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取 ts.Program 以用作生成后续增量编译的起点</span></span><br><span class="line">  <span class="comment">// NgCompiler 产生一个内部增量 TypeScript 编译（为了模板类型检查的目的，将消费者的 `ts.Program` 继承到一个新的编译器中）</span></span><br><span class="line">  <span class="comment">// 此操作后，消费者的 ts.Program 不再可用于启动新的增量编译，getNextProgram 检索可以替代使用的 ts.Program</span></span><br><span class="line">  getNextProgram(): ts.Program &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异步执行 Angular 的分析步骤</span></span><br><span class="line">  <span class="comment">// 通常，每当调用 getDiagnostics 或 prepareEmit 时，都会延迟执行此操作</span></span><br><span class="line">  <span class="comment">// 然而，某些消费者可能希望允许分析的异步阶段，其中诸如 “styleUrls” 之类的资源被异步解析</span></span><br><span class="line">  <span class="comment">// 在这些情况下，必须首先调用 analyzeAsync，并且在调用 NgCompiler 的任何其他 API 之前等待它的 Promise</span></span><br><span class="line">  <span class="keyword">async</span> analyzeAsync(): <span class="built_in">Promise</span>&lt;<span class="built_in">void</span>&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 列出在分析过程中检测到的惰性路由</span></span><br><span class="line">  listLazyRoutes(entryRoute?: <span class="built_in">string</span>): LazyRoute[] &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，<code>NgCompiler</code>主要负责将 Angular 编译集成到 TypeScript 编译器的编译流程中，并支持了上述提到的错误信息诊断（类型检查）、依赖关系检索，其中的设计还支持了增量编译、异步编译等能力。</p><h2 id="ngtsc-编译器"><a href="#ngtsc-编译器" class="headerlink" title="ngtsc 编译器"></a>ngtsc 编译器</h2><p><code>ngtsc</code>是一个 Typescript-to-Javascript 编译器。它是一个最小包装器，包裹在<code>tsc</code>之外，而<code>tsc</code>中则包含一系列的 Angular 变换。</p><h3 id="编译器流程"><a href="#编译器流程" class="headerlink" title="编译器流程"></a>编译器流程</h3><p>和<code>tsc</code>一样，当<code>ngtsc</code>开始运行时，它首先解析<code>tsconfig.json</code>文件，然后创建一个<code>ts.Program</code>。在上述转换可以运行之前，需要进行几件事情：</p><ul><li>为包含修饰符的输入源文件收集元数据</li><li><code>@Component</code>装饰器中列出的资源文件必须异步解析<ul><li>例如 CLI 中，可能希望运行的 WebPack 以产生<code>.css</code>输入到<code>styleUrls</code>的属性<code>@Component</code></li></ul></li><li>运行诊断程序，这会创建<code>TypeChecker</code>并触及程序中的每个节点（一个相当昂贵的操作）</li></ul><p>因为资源加载是异步的（特别是可能通过子进程并发），所以最好在做任何昂贵的事情之前启动尽可能多的资源加载。</p><p><code>ngtsc</code>的运行入口位于<code>NgtscProgram</code>中，可直接替代传统的 View Engine 编译器到诸如命令行<code>main()</code>函数或 Angular 之类的工具命令行界面。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> NgtscProgram <span class="keyword">implements</span> api.Program &#123;</span><br><span class="line">  readonly compiler: NgCompiler;</span><br><span class="line">  <span class="comment">// 主要的 TypeScript 程序，用于分析和发出</span></span><br><span class="line">  <span class="keyword">private</span> tsProgram: ts.Program;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> closureCompilerEnabled: <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="keyword">private</span> host: NgCompilerHost;</span><br><span class="line">  <span class="keyword">private</span> incrementalStrategy: TrackedIncrementalBuildStrategy;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器流程如下所示：</p><ol><li>创建<code>ts.Program</code>。</li><li>扫描源文件以查找具有微不足道的可检测<code>@Component</code>注释的顶级声明，这避免了创建<code>TypeChecker</code>。<ul><li>对于每个具有<code>templateUrlor</code>的此类声明<code>styleUrls</code>，启动该 URL 的资源加载并将加入<code>Promise</code>队列</li></ul></li><li>获取诊断信息并报告任何初始错误消息。此时，<code>TypeChecker</code>已准备就绪。</li><li>对<code>@Component</code>注释进行彻底扫描，使用<code>TypeChecker</code>和元数据系统来解析任何复杂的表达式。</li><li>等待所有资源得到解决。</li><li>计算需要应用的一组变换。</li><li>启动<code>Tsickle</code>发射，它运行变换。</li><li>在<code>.d.ts</code>文件的发出回调期间，重新解析发出的<code>.d.ts</code>并合并来自<code>Angular</code>编译器的任何请求更改。</li></ol><p>Angular 编译涉及将 Angular 装饰器转换为静态定义字段。在构建时，这是在 TypeScript 编译的整个过程中完成的，其中 TypeScript 代码经过类型检查，然后降级为 JavaScript 代码。在此过程中，还可以生成特定于 Angular 的诊断。</p><h3 id="增量编译"><a href="#增量编译" class="headerlink" title="增量编译"></a>增量编译</h3><p>前面我们介绍了 Ivy 编译器的一些特性，其中包括了通过增加增量编译，来缩短构建时间。</p><p>作为在 TypeScript 编译器中执行 Angular 编译的核心 API，<code>NgCompiler</code>的每个实例都支持单个编译，因此也支持增量编译。</p><p>Angular 编译器能够进行增量编译，其中来自先前编译的信息用于加速下一次编译。在编译期间，编译器产生两种主要信息：本地信息（如组件和指令元数据）和全局信息（如具体化的<code>NgModule</code>范围）。增量编译通过两种方式进行管理：</p><ol><li>对于大多数更改，新的<code>NgCompiler</code>可以有选择地从以前的实例继承本地信息，并且只需要在底层 TypeScript 文件发生更改的地方重新计算它。在这种情况下，全局信息总是从头开始重新计算。</li><li>对于特定的更改，例如组件资源中的更改，<code>NgCompiler</code>可以整体重用，并更新以合并此类更改的影响，而无需重新计算任何其他信息。</li></ol><p>请注意，这两种模式在是否需要新<code>NgCompiler</code>实例或是否可以重用之前的实例方面有所不同。为了防止泄漏这种实现的复杂性并保护消费者不必管理<code>NgCompiler</code>如此具体的生命周期，这个过程通过<code>CompilationTicket</code>进行了抽象。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> CompilationTicket =</span><br><span class="line">  <span class="comment">// 从头开始 Angular 编译操作</span></span><br><span class="line">  FreshCompilationTicket | </span><br><span class="line">  <span class="comment">// 开始包含对 TypeScript 代码的更改的 Angular 编译操作</span></span><br><span class="line">  IncrementalTypeScriptCompilationTicket | </span><br><span class="line">  IncrementalResourceCompilationTicket;</span><br></pre></td></tr></table></figure><p><code>CompilationTicket</code>用于初始化（或更新）<code>NgCompiler</code>实例，该实例为 Angular 编译器的核心。<code>CompilationTicket</code>抽象了编译的起始状态，并允许独立于任何增量编译生命周期管理<code>NgCompiler</code>。</p><p>消费者首先获得一个<code>CompilationTicket</code>（取决于传入更改的性质），然后使用该票据获取<code>NgCompiler</code>实例。在创建<code>CompilationTicket</code>时，编译器可以决定是重用旧<code>NgCompiler</code>实例还是创建新实例。</p><h3 id="异步编译"><a href="#异步编译" class="headerlink" title="异步编译"></a>异步编译</h3><p>在某些编译环境（例如 Angular CLI 中的 Webpack 驱动编译）中，编译的各种输入只能以异步方式生成。例如，<code>styleUrls</code>链接到 SASS 文件的 SASS 编译需要产生一个子 Webpack 编译。为了支持这一点，Angular 有一个异步接口来加载这些资源。</p><p>如果使用此接口，则<code>NgCompiler</code>创建后的另一个异步步骤是调用<code>NgCompiler.analyzeAsync</code>并等待其<code>Promise</code>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> NgtscProgram <span class="keyword">implements</span> api.Program &#123;</span><br><span class="line">   ...</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 确保 NgCompiler 已正确分析程序，并允许在此过程中异步加载任何资源。</span></span><br><span class="line"><span class="comment">    * Angular CLI 使用它来允许为 styleUrls 中使用的 SASS 文件等内容生成（异步）子编译。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  loadNgStructureAsync(): <span class="built_in">Promise</span>&lt;<span class="built_in">void</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.compiler.analyzeAsync();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此操作完成后，所有资源均已加载，其余<code>NgCompilerAPI</code>可以同步使用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Angular 是一套大而全的解决方案，想必大家早已对此有所了解。但实际上 Angular 做了很多深度的设计和能力，包括给开发者更好的体验，比如模板类型检查中，是如何将这些 Angular 特定的类型检查能力添加到 TypeScript 编译过程中，并且能通过文件映射能准确反馈给用户具体的代码位置，这些都是作为开发者的我未曾考虑过的。</p><p>感觉 Angular 里面还有特别多值得学习的东西。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://github.com/angular/angular/blob/master/packages/compiler/design/architecture.md" target="_blank" rel="noopener">DESIGN DOC(Ivy): Compiler Architecture</a></li><li><a href="https://indepth.dev/posts/1151/a-deep-dive-into-injectable-and-providedin-in-ivy" target="_blank" rel="noopener">A Deep Dive into @Injectable and providedIn in Ivy</a></li><li><a href="https://indepth.dev/posts/1062/ivy-engine-in-angular-first-in-depth-look-at-compilation-runtime-and-change-detection" target="_blank" rel="noopener">Ivy engine in Angular: first in-depth look at compilation, runtime and change detection</a></li><li><a href="https://indepth.dev/posts/1053/everything-you-need-to-know-about-change-detection-in-angular" target="_blank" rel="noopener">Everything you need to know about change detection in Angular</a></li><li><a href="https://www.youtube.com/watch?v=anphffaCZrQ" target="_blank" rel="noopener">Deep Dive into the Angular Compiler | Alex Rickabaugh</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为“为大型前端项目”而设计的前端框架，Angular 其实有许多值得参考和学习的设计，本系列主要用于研究这些设计和功能的实现原理。本文围绕 Angular 的核心功能 Ivy 编译器，介绍其中CLI层面的编译器编译过程。&lt;/p&gt;
    
    </summary>
    
      <category term="Angular源码" scheme="https://godbasin.github.io/categories/Angular%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="功能设计" scheme="https://godbasin.github.io/tags/%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>浏览器是如何进行页面渲染的</title>
    <link href="https://godbasin.github.io/2021/10/16/web-browser-render/"/>
    <id>https://godbasin.github.io/2021/10/16/web-browser-render/</id>
    <published>2021-10-16T08:22:23.000Z</published>
    <updated>2021-10-16T08:23:43.143Z</updated>
    
    <content type="html"><![CDATA[<p>作为前端开发，我们的日常工作中除了写代码之外，几乎大多数的时间都在跟浏览器打交道。当然，现在我们甚至写代码都可以直接在浏览器里完成，一个浏览器走天下。</p><p>因此，我们应该对浏览器的了解要更加深入，除了了解怎么使用和调试浏览器，我们还要掌握它是怎样将我们编写的代码渲染到页面中的。</p><a id="more"></a><h2 id="认识浏览器"><a href="#认识浏览器" class="headerlink" title="认识浏览器"></a>认识浏览器</h2><p>浏览器的主要功能，是通过向服务器请求并在浏览器窗口中展示 Web 资源内容，通常包括 HTML 文档、PDF、图片等，我们也可以通过插件的方式加载更多其他的资源类型（比如播放视频）。</p><p>对于浏览器的问题，HTTP 请求相关的，想必各位在面试的时候都被问烂了吧，这里直接过一下浏览器中的 HTTP 请求过程：</p><ol><li>DNS 域名解析（此处涉及 DNS 的寻址过程），找到网页的存放服务器。</li><li>浏览器与服务器建立 TCP 连接。</li><li>浏览器发起 HTTP 请求。</li><li>服务器响应 HTTP 请求，返回该页面的 HTML 内容。</li><li>浏览器解析 HTML 代码，并请求 HTML 代码中的资源（如 JavaScript、CSS、图片等，此处可能涉及 HTTP 缓存）。</li><li>浏览器对页面进行渲染呈现给用户。</li></ol><p>这篇文章会重点介绍第 6 步，该步骤涉及浏览器的渲染过程和原理。除了初次加载页面，用户的很多操作都同样涉及到浏览器渲染，比如以下功能：</p><ul><li>地址栏输入 URL</li><li>点击刷新和停止按钮，控制页面加载</li><li>点击后退和前进按钮，快速实现页面跳转</li><li>书签和收藏，快速打开页面</li></ul><p>除了这些，实际上我们和浏览器的几乎所有操作，都涉及到浏览器的渲染过程。为了更深刻地认识这些过程，我们先来认识下浏览器的结构。</p><p>HTML 和 CSS 规范中规定了浏览器解析和渲染 HTML 文档的方式，曾经各个浏览器都只遵循其中一部分，因此前端开发经常需要兼容各种浏览器。现在这些问题已经得到改善，同时配合 Babel 等一些兼容性处理编译过程，我们可以更加关注网站的功能实现和优化。</p><h3 id="浏览器的结构"><a href="#浏览器的结构" class="headerlink" title="浏览器的结构"></a>浏览器的结构</h3><p>从结构上来说，浏览器主要包括了八个子系统：用户界面、浏览器引擎、渲染引擎、网络子系统、JavaScript 解释器、XML 解析器、显示后端、数据持久性子系统。</p><p><img src="https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/how-browser-works-1.jpg" alt></p><p>这些子系统组合构成了我们的浏览器，而谈到页面的加载和渲染，则离不开网络子系统、渲染引擎、JavaScript 解释器和浏览器引擎等。</p><p>如今大多数用户主要使用的浏览器包括两类：</p><ul><li>台式机：Chrome、Internet Explorer、Firefox、Safari、Opera 等</li><li>移动设备：Android 浏览器、iPhone、Opera Mini、Opera Mobile、UC 浏览器、Chrome 等。</li></ul><p>下面我们以前端开发最常使用的 Chrome 浏览器为例（因为 Chrome 浏览器太牛啦，而且它们还要官方文章介绍做参考），进行更详细的介绍。</p><h3 id="Chrome-多进程架构"><a href="#Chrome-多进程架构" class="headerlink" title="Chrome 多进程架构"></a>Chrome 多进程架构</h3><p>应该很多前端开发都知道，Chrome 浏览器使用了多进程架构，包括浏览器进程、渲染器进程、插件进程和 GPU 进程：</p><p><img src="https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/browserui.png" alt></p><p>如今，基本上所有的浏览器都支持多个选项卡。在 Chrome 中，每个选项卡在单独的渲染器进程中运行，渲染器进程主要用于控制和处理选项卡中的网站内容显示。渲染器进程支持多线程，包括：</p><ul><li>GUI 渲染线程：负责对浏览器界面进行渲染</li><li>JavaScript 引擎线程：负责解析和执行 JavaScript 脚本</li><li>浏览器定时器触发线程：<code>setTimeout</code>和<code>setInterval</code>所在的线程</li><li>浏览器事件触发线程：该线程负责处理浏览器事件，并将事件触发后需要执行的代码放置到 JavaScript 引擎中执行</li></ul><p>选项卡之外的所有内容都由浏览器进程处理，浏览器进程则主要用于控制和处理用户可见的 UI 部分（包括地址栏，书签，后退和前进按钮）和用户不可见的隐藏部分（例如网络请求和文件访问）。浏览器进程同样支持多线程，包括：</p><ul><li>UI 线程：用于绘制浏览器的按钮和输入字段</li><li>网络线程：用于处理网络请求，以及从服务器接收数据</li><li>存储线程：用于控制对文件的访问</li></ul><p>这些线程其实我们在学习其他内容的时候也会涉及到，比如在页面的加载过程中，涉及 GUI 渲染线程与 JavaScript 引擎线程间的互斥关系，因此页面中的<code>&lt;script&gt;</code>和<code>&lt;style&gt;</code>元素设计不合理会影响页面加载速度。</p><p>除此之外，UI 线程、网络线程、存储线程、浏览器事件触发线程、浏览器定时器触发线程中 I/O 事件通过异步任务完成时触发的函数回调，解决了单线程的 Javascript 阻塞问题。结合 Event Loop 的并发模型设计，解决了 Javascript 中同步任务和异步任务的管理问题。</p><p>下面我们来介绍浏览器中页面的渲染过程，该部分内容同样基于 Chrome 浏览器，更加详细地介绍浏览器进程和线程如何通信来显示页面。</p><h2 id="浏览器中页面的渲染过程"><a href="#浏览器中页面的渲染过程" class="headerlink" title="浏览器中页面的渲染过程"></a>浏览器中页面的渲染过程</h2><p>首先我们将浏览器中页面的渲染过程分为两部分：</p><ol><li>页面导航：用户输入 URL，浏览器进程进行请求和准备处理。</li><li>页面渲染：获取到相关资源后，渲染器进程负责选项卡内部的渲染处理。</li></ol><h3 id="1-页面导航"><a href="#1-页面导航" class="headerlink" title="1. 页面导航"></a>1. 页面导航</h3><p>前面我们介绍了一个 HTTP 的请求过程，该部分内容更倾向于将浏览器当成一个完整的对象，来介绍浏览器与外界的交互过程。</p><p>下面，我们来深入浏览器内部来进行分析，当用户在地址栏中输入内容时：</p><ol><li>首先浏览器进程的 UI 线程会进行处理：如果是 URI，则会发起网络请求来获取网站内容；如果不是，则进入搜索引擎。</li><li>如果需要发起网络请求，请求过程由网络线程来完成。HTTP 请求响应如果是 HTML 文件，则将数据传递到渲染器进程；如果是其他文件则意味着这是下载请求，此时会将数据传递到下载管理器。</li><li>如果请求响应为 HTML 内容，此时浏览器应导航到请求站点，网络线程便通知 UI 线程数据准备就绪。</li><li>接下来，UI 线程会寻找一个渲染器进程来进行网页渲染。当数据和渲染器进程都准备好后，HTML 数据通过 IPC 从浏览器进程传递到渲染器进程中。</li><li>渲染器进程接收 HTML 数据后，将开始加载资源并渲染页面。</li><li>渲染器进程完成渲染后，通过 IPC 通知浏览器进程页面已加载。</li></ol><p>以上是用户在地址栏输入网站地址，到页面开始渲染的整体过程。如果当前页面跳转到其他网站，浏览器将调用一个单独的渲染进程来处理新导航，同时保留当前渲染进程来处理像<code>unload</code>这类事件。</p><p>可以看到，页面导航的过程主要依赖浏览器进程。其中，上述过程中的步骤 5 便是页面的渲染部分，该过程同样依赖渲染器进程，我们一起来看看。</p><h3 id="2-页面渲染"><a href="#2-页面渲染" class="headerlink" title="2. 页面渲染"></a>2. 页面渲染</h3><p>前面说过，渲染器进程负责选项卡内部发生的所有事情，它的核心工作是将 HTML、CSS 和 JavaScript 转换为可交互的页面。整体上，渲染器进程渲染页面的流程基本如下：</p><ul><li>解析(Parser)：解析 HTML/CSS/JavaScript 代码</li><li>布局(Layout)：定位坐标和大小、是否换行、各种<code>position</code>/<code>overflow</code>/<code>z-index</code>属性等计算</li><li>绘制(Paint)：判断元素渲染层级顺序</li><li>光栅化(Raster)：将计算后的信息转换为屏幕上的像素</li></ul><p>大致流程如下图：</p><p><img src="https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/flow.png" alt="浏览器构造渲染树流程"></p><p>我们来分别看下。</p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>渲染器进程的主线程会解析以下内容：</p><ul><li>解析 HTML 内容，产生一个 DOM 节点树</li><li>解析 CSS，产生 CSS 规则树</li><li>解析 Javascript 脚本。由于 Javascript 脚本可以通过 DOM API 和 CSSOM API 来操作 DOM 节点树和 CSS 规则树，因此该过程中会等待 JavaScript 运行完成才继续解析 HTML</li></ul><p>解析完成后，我们得到了 DOM 节点树和 CSS 规则树，布局过程便是通过 DOM 节点树和 CSS 规则树来构造渲染树（Render Tree）。</p><h4 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h4><p>通过解析之后，渲染器进程知道每个节点的结构和样式，但如果需要渲染页面，浏览器还需要进行布局，布局过程其实便是我们常说的渲染树的创建过程。</p><p>在这个过程中，像<code>header</code>或<code>display:none</code>的元素，它们会存在 DOM 节点树中，但不会被添加到渲染树里。</p><p>布局完成后，将会进入绘制环节。</p><h4 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h4><p>在绘制步骤中，渲染器主线程会遍历渲染树来创建绘制记录。</p><p>需要注意的是，如果渲染树发生了改变，则渲染器会触发重绘（Repaint）和重排（Reflow）：</p><ul><li>重绘：屏幕的一部分要重画，比如某个 CSS 的背景色变了，但是元素的几何尺寸没有变</li><li>重排：元素的几何尺寸变了（渲染树的一部分或全部发生了变化），需要重新验证并计算渲染树</li></ul><p>为了不对每个小的变化都进行完整的布局计算，渲染器会将更改的元素和它的子元素进行脏位标记，表示该元素需要重新布局。其中，全局样式更改会触发全局布局，部分样式或元素更改会触发增量布局，增量布局是异步完成的，全局布局则会同步触发。</p><p>重排需要涉及变更的所有的结点几何尺寸和位置，成本比重绘的成本高得多的多。所以我们要注意以避免频繁地进行增加、删除、修改 DOM 结点、移动 DOM 的位置、Resize 窗口、滚动等操作，因为可能会导致性能降低。</p><h4 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h4><p>通过解析、布局和绘制过程，浏览器获得了文档的结构、每个元素的样式、绘制顺序等信息。将这些信息转换为屏幕上的像素，这个过程被称为光栅化。</p><p>光栅化可以被 GPU 加速，光栅化后的位图会被存储在 GPU 内存中。根据前面介绍的渲染流程，当页面布局变更了会触发重排和重绘，还需要重新进行光栅化。此时如果页面中有动画，则主线程中过多的计算任务很可能会影响动画的性能。</p><p>因此，现代的浏览器通常使用合成的方式，将页面的各个部分分成若干层，分别对其进行栅格化（将它们分割成了不同的瓦片），并通过合成器线程进行页面的合成：</p><p><img src="https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/how-browser-works-2.jpg" alt></p><p>合成过程如下：</p><ol><li>当主线程创建了合成层并确定了绘制顺序，便将这些信息提交给合成线程。</li><li>合成器线程将每个图层栅格化，然后将每个图块发送给光栅线程。</li><li>光栅线程栅格化每个瓦片，并将它们存储在 GPU 内存中。</li><li>合成器线程通过 IPC 提交给浏览器进程，这些合成器帧被发送到 GPU 进程处理，并显示在屏幕上。</li></ol><p>合成的真正目的是，在移动合成层的时候不用重新光栅化。因为有了合成器线程，页面才可以独立于主线程进行流畅的滚动。</p><p>到这里，页面才真正渲染到屏幕上。</p><p>我们在绘制页面的时候，也可能会遇到很多奇怪的渲染问题，比如使用了<code>transform:scale</code>可能会导致某些浏览器中渲染模糊，究其原因则是由于光栅化过程导致的。像前面所说，前端开发需要频繁跟浏览器打交道，所谓知己知彼百战不殆，我们应该对其运行过程有更好的了解。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>这里主要介绍了浏览器的组成和结构，并从浏览器内部分工角度来介绍页面的渲染过程。掌握页面的渲染过程，有利于我们进行一些性能优化，尤其如果涉及动画、游戏等频繁绘制的场景，渲染性能往往是需要不断进行优化的瓶颈。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>对于介绍浏览器的渲染过程相关的内容，非常推荐大家参考两篇文章：</p><ul><li><a href="https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/" target="_blank" rel="noopener">《How Browsers Work: Behind the scenes of modern web browsers》</a></li><li><a href="https://developers.google.com/web/updates/2018/09/inside-browser-part1" target="_blank" rel="noopener">《Inside look at modern web browser》</a>（分为四篇，左侧导航栏可以找到）</li></ul><p>这篇文章也是参考了这两篇文章以及一些论文，以我自己的理解来进行总结输出，推荐大家也要阅读原文哦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为前端开发，我们的日常工作中除了写代码之外，几乎大多数的时间都在跟浏览器打交道。当然，现在我们甚至写代码都可以直接在浏览器里完成，一个浏览器走天下。&lt;/p&gt;
&lt;p&gt;因此，我们应该对浏览器的了解要更加深入，除了了解怎么使用和调试浏览器，我们还要掌握它是怎样将我们编写的代码渲染到页面中的。&lt;/p&gt;
    
    </summary>
    
      <category term="js什锦" scheme="https://godbasin.github.io/categories/js%E4%BB%80%E9%94%A6/"/>
    
    
      <category term="分享" scheme="https://godbasin.github.io/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>前端这几年--11.关于一年一换的魔咒</title>
    <link href="https://godbasin.github.io/2021/10/10/about-front-end-11/"/>
    <id>https://godbasin.github.io/2021/10/10/about-front-end-11/</id>
    <published>2021-10-10T03:00:13.000Z</published>
    <updated>2021-10-10T03:09:42.601Z</updated>
    
    <content type="html"><![CDATA[<p>工作也有些年了，虽然常常换工作，但实际上我也很希望有一份热爱又持久的工作。</p><a id="more"></a><h2 id="换工作的魔咒？"><a href="#换工作的魔咒？" class="headerlink" title="换工作的魔咒？"></a>换工作的魔咒？</h2><p>总觉得自己身上有一个职业魔咒：每年都得换一次工作/工作环境。</p><p>如果算上部门内的主动调整，该魔咒的的确确从未被打破，从 2014 年开始一直到现在。</p><p>我常常在想，到底是自身的问题呢，还是命中注定？毕竟换了不少工作，的的确确还是要从自己身上找找问题。</p><h2 id="是什么击退了你的热情？"><a href="#是什么击退了你的热情？" class="headerlink" title="是什么击退了你的热情？"></a>是什么击退了你的热情？</h2><p>我是一个热爱自由的人，说得好听点就是自我意识很强，说得不好听，就是“自私”、“自我”、“任性”。</p><p>一些大佬们对我的评价常常是：能力很强，很特别，但不好管理。作为一个打工人，我的自我意识有些过剩。团队对每一位成员都有所要求，领导们也会对大家有所期待，同样的，我也会对所在的团队、对领导们有反向的要求和期待。</p><p>因此，磨合是我常常会遇到的问题。而实际上，工作后遇到的人基本上也都有各自的价值观和思考方式了，即使再怎么尝试，一些观念和目标也无法达成一致。</p><p>我最喜欢的状态是，一个团队内的成员，都有一致的目标，共同往一个方向努力。实际上，规模越大的团队，就越难达成这样的状态。当合作、相处的人开始各自有了自己的打算，竞争意识已经超过了合作意识，相互之间开始抢功劳、甩锅，甚至仅仅是目标的不一致，都会导致工作上的不顺畅。</p><p>有句老话：将爱好当做工作，最终会丢掉这个爱好。</p><p>实际上，工作中最初拥有的热情，都是在各种磨合、冲突、矛盾中一点点失去的。直到我们失望了，热情消退了，便“仅仅把工作当做是维持生活的手段”。工作逐渐难以有所期待，于是我们期盼着生活里能有所改变，成家和生育便是一种不错的选择。</p><p>我也是凭着爱好成为开发，让我疲惫的往往不是写代码本身，而是工作中遇到难以磨合的问题。常常产生矛盾的点在于，每个人的取舍并不一致。举个例子，我认为技术最终是服务于产品和用户的，产品的体验、用户的感受很重要。而对于很多人来说，关注技术和 KPI 会对职业发展更重要。这是一个常见的矛盾点，虽然这样的矛盾并不存在高低之分、也不存在对与错，但它会影响到我们工作中对各个事情的优先级划分。</p><p>最常见的，莫过于我们常常需要主动 push 其他人，来协作完成我们需要的一些事情。因为在对方眼里，很可能有对他来说更重要的事情要做。</p><p>这本来是一件很普通、很小的事情，但夹杂着个人情绪、特殊场景之后，就容易被放大。我们都知道相互理解和尊重是沟通的基础，但工作中能做到的人并不多，所以我们常常会跟别人产生各种冲突和矛盾，这会导致我们慢慢对工作失去了耐心和热情。</p><h3 id="为何无法专注做一件事？"><a href="#为何无法专注做一件事？" class="headerlink" title="为何无法专注做一件事？"></a>为何无法专注做一件事？</h3><p>全神贯注写代码的时候很开心，但每天能专注写代码的时间却很少，因为一份工作对我们的要求远不止如此。我们要有 owner 意识，要主动发现问题和解决问题，主动思考如何优化。</p><p>随着职级的上升，对开发要求中，代码实现往往占比越来越小。推动方案落地，常常需要多方配合，需要不少的沟通成本；推动项目按照预期运行，又涉及各种风险把控、多方的进度管控。开发需要一专多长，方案调研、项目管理、风险管控、沟通能力、推动能力，一个本只需认真思考更优实现的人，被要求将精力分散到各个地方。</p><p>对于研发群体来说，适合全方面发展的人本就少之又少，因此大多数的人，对涉及沟通的事情觉得疲惫和无趣。而多线程处理事情，对于很多人来说都难以做好，常常会顾此失彼，因此对于大多数研发来说，更适合给予某个领域让其负责。</p><p>理想情况下，大多数的研发只需要负责好自己手上的事情，少部分热爱又擅长沟通的人将其管理和串联起来，便是较和谐高效的协作方式。</p><p>至于如今大多数工作都对我们有了更多的要求，主要原因大概是：</p><ol><li>有挑战、需要完全专注和具备技术不可替代性，这样的工作内容很少。</li><li>僧多粥少，工作内容的简单性，直接提升了开发人员的可替代性。</li><li>为了提升竞争力，因此个人、团队都对普遍群体有了更多的要求。</li></ol><p>因此，专注地做自己热爱的事情，对于大部分的人来说，这样的工作选择少之又少。相比之下，选择提升个人竞争力、获得更好的待遇，才是大多数人的选择。</p><h3 id="怎样的团队能做出好的产品？"><a href="#怎样的团队能做出好的产品？" class="headerlink" title="怎样的团队能做出好的产品？"></a>怎样的团队能做出好的产品？</h3><p>我最近常常在思考，导致团队目标割裂、难以做出团队成员自身也认可的产品的原因，到底在哪里？</p><p>从团队规模来看，小团队的确更容易比大团队达到目标的一致性，也更容易各司其职地专注自身的领域，齐心协力产品获得更好的体验。由于团队的一致性对每个团队成员都有要求，因此小团队可通过严格把控成员质量来达成，比如选择目标一致的成员。而在大团队里，不可避免地产生利益分歧，从而导致人人自危。</p><p>而在如今大多数的大公司体制下，产品的成败与个人的关系有所割裂。产品做得好，并不意味着团队里的每个人都有理想的收益；产品做得差，也并不是团队中的每个人都需要承担结果。</p><p>很多公司都有绩效考核与职级晋升两种激励体系，这两种激励是与团队成员有最直接利益关系。因为开发的工作往往无法量化，都是由直接或间接上级给出结果，因此，KPI 工程、PPT 工程、汇报氛围也一并形成。相比于思考把产品做好，替领导解决问题、提升自己在团队的影响力、建立自身的技术壁垒，更容易获得直接的收益，而后者并不一定需要把产品做好。</p><p>因此，在这样的环境下，大部分团队成员并不在意产品是否能获得成功，也很少认为自己会与该产品生死与共。底层抢着去做更容易晋升、更容易拿到好的考核的工作内容，上层也在思考怎样扩大团队规模、也给团队提供更多的机会，而产品是否做得好，或许只有该产品的初创者、拥护者会在乎，而他们往往又难以在这样的氛围内坚持下来。</p><p>所以，经历了好些快速扩招的团队之后，我对选择迅速扩招的团队有着极高的警惕。但事实上只要在这样的体制内，只要产品的发展看起来比较顺利，或是还有机会，团队扩招显然无法避免。</p><p>从这样的角度来看，产品发展得顺利，也不知是祸是福。</p><h3 id="能动性和惰性的平衡？"><a href="#能动性和惰性的平衡？" class="headerlink" title="能动性和惰性的平衡？"></a>能动性和惰性的平衡？</h3><p>团队对成员是有所要求的，这样的要求有时候会推动其成长，有时候却也会抑制其能动性。</p><p>我们常常说，具体情况具体分析。对于不同性格、脾气、追求的人，找到其闪光点并提供让其发挥出能力的环境，这对管理者有极高的要求。而大多数管理者都难以做到，因此会选择更加简单的管理方式，抹平团队差异性，通过培训、考试以及粗暴的横向对比、优胜劣汰，统一团队倾向和能力，批量产出高可替代性的团队成员。</p><p>大多数的产品开发，很多时候都是用常规的方式和套路便可，并不需要能力突出的团队成员。而对于追求极致和需要突破的产品来说，则需要个性更强的成员来推动产品发展。</p><p>如果想成为管理者，那么很大程度上要接受自己并不能完美地面面俱到，更多时候还是需要学习使用简单粗暴的管理方式，来维护和管理团队。</p><p>对于团队管理来说如此，那么对于团队的个人呢？</p><p>作为团队的成员，是愿意适应被抹平个人的差异性，被团队推动着，努力提升自身的短板不被淘汰呢？还是更希望突显个人的优势，积极主动地发挥自身的能动性呢？这或许是我一直都在思考的问题。</p><p>而个人的优势究竟在哪，也是很多人一直在寻找的答案。</p><p>千里马常有，而伯乐不常有。但我也常问自己，千里马一定要有伯乐才能成为千里马吗？又或者，千里马的伯乐，不可以是千里马自己吗？我们也可以给自己多一点的信心，给自己多一些的机会。</p><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>一直以来，我的心里有一个想象中理想的团队，这也是我不断更换工作环境的原因。</p><p>理想的团队极难寻得，且即使找到，团队依然在不断变化，团队里的人也在不断变化。曾经有好几次，最初加入的团队环境和氛围都十分喜欢，但随着产品不断发展，团队在扩招过程发生了许多事情，最终原先喜欢的那种感觉早已不在，热爱不再。</p><p>我也常常在想，团队规模的调整，的确不可避免地给团队带来一些冲击，那么，团队在调整之后是否能与原先达成一个平衡呢？还是说原有的能动性、开放性、突显的个性是否都难以共存呢？我还在观望。</p><p>理想的团队，到底会存在吗？</p><p>真希望有一天能打破这一年一换的魔咒呀。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作也有些年了，虽然常常换工作，但实际上我也很希望有一份热爱又持久的工作。&lt;/p&gt;
    
    </summary>
    
      <category term="工作这杯茶" scheme="https://godbasin.github.io/categories/%E5%B7%A5%E4%BD%9C%E8%BF%99%E6%9D%AF%E8%8C%B6/"/>
    
    
      <category term="心态" scheme="https://godbasin.github.io/tags/%E5%BF%83%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>Angular框架解读--Ivy编译器的视图数据和依赖解析</title>
    <link href="https://godbasin.github.io/2021/09/19/angular-design-ivy-1-view-data-and-node-injector/"/>
    <id>https://godbasin.github.io/2021/09/19/angular-design-ivy-1-view-data-and-node-injector/</id>
    <published>2021-09-19T11:10:12.000Z</published>
    <updated>2021-09-19T11:12:06.441Z</updated>
    
    <content type="html"><![CDATA[<p>作为“为大型前端项目”而设计的前端框架，Angular 其实有许多值得参考和学习的设计，本系列主要用于研究这些设计和功能的实现原理。本文主要介绍在 Angular 的 Ivy 编译器中，是如何管理和查找视图数据的。</p><a id="more"></a><h2 id="Ivy-模型"><a href="#Ivy-模型" class="headerlink" title="Ivy 模型"></a>Ivy 模型</h2><p>在<a href="https://godbasin.github.io/2021/08/15/angular-design-ivy-0-design/">上一节《Ivy 编译器整体设计》</a>中，我们从整体上介绍了 Ivy 编译器主要做的一些事情，包括模板编译、TypeScript 解析器等。我们可以看到 Ivy 编译器实现了更优的 Tree-shaking 支持、组件的延迟加载、支持增量编译等，而达到这些效果的一个核心设计点便在于视图的解析和数据管理。</p><h3 id="视图数据-LView-TView"><a href="#视图数据-LView-TView" class="headerlink" title="视图数据 LView/TView"></a>视图数据 LView/TView</h3><p>在 Angular Ivy 中，使用了<code>LView</code>和<code>TView.data</code>来管理和跟踪渲染模板所需要的内部数据。</p><p>其中，<code>LView</code>存储了从模板调用指令时，处理指令所需的所有信息。每个嵌入式视图和组件视图都有自己的<code>LView</code>，我们来看看<code>LView</code>的定义：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> LView <span class="keyword">extends</span> Array&lt;any&gt; &#123;</span><br><span class="line">  <span class="comment">// 插入该 LView 的节点</span></span><br><span class="line">  [HOST]: RElement | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 此视图的静态数据</span></span><br><span class="line">  readonly [TVIEW]: TView;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 父视图</span></span><br><span class="line">  [PARENT]: LView | LContainer | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下一个同级视图或容器</span></span><br><span class="line">  [NEXT]: LView | LContainer | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对此视图有效的查询-视图中的节点将报告给这些查询</span></span><br><span class="line">  [QUERIES]: LQueries | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储当前 LView 插入位置的 TNode</span></span><br><span class="line">  [T_HOST]: TNode | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当视图被破坏时，需要释放侦听器，并且必须取消订阅输出</span></span><br><span class="line">  [CLEANUP]: <span class="built_in">any</span>[] | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 上下文信息</span></span><br><span class="line">  [CONTEXT]: &#123;&#125; | RootContext | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在咨询了元素注入器之后，将使用可选的模块注入器作为回退</span></span><br><span class="line">  readonly [INJECTOR]: Injector | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于创建渲染器的工厂</span></span><br><span class="line">  [RENDERER_FACTORY]: RendererFactory3;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 要用于此视图的渲染器</span></span><br><span class="line">  [RENDERER]: Renderer3;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 引用层次结构中此 LView 下的第一个 LView 或 LContainer</span></span><br><span class="line">  [CHILD_HEAD]: LView | LContainer | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 层次结构中此 LView 下的最后一个 LView 或 LContainer</span></span><br><span class="line">  [CHILD_TAIL]: LView | LContainer | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查看声明此视图的模板的位置</span></span><br><span class="line">  [DECLARATION_VIEW]: LView | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 指向声明组件视图，用于跟踪已移植的 LView</span></span><br><span class="line">  [DECLARATION_COMPONENT_VIEW]: LView;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 嵌入视图的声明点（基于 &lt;ng-template&gt; 的内容实例化的声明点），其他类型的视图为 null</span></span><br><span class="line">  [DECLARATION_LCONTAINER]: LContainer | <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们能看到，<code>LView</code>中存储了足够多的信息，这样的设计使单个数组可以以紧凑的形式包含模板渲染所需的所有必要数据。</p><p>其中，<code>[TVIEW]</code>为该视图的静态数据，存储了所有可在模板实例之间共享的信息（比如<code>template</code>、<code>components</code>、<code>data</code>以及各种钩子），以便可以轻松地在 DI 中遍历节点树并获取与节点（存储指令<code>defs</code>的节点）关联的<code>TView.data</code>数组。这些信息存储在<code>ComponentDef.tView</code>中。</p><p>显然，<code>LView</code>还存储了除此之外的所有渲染模板需要的信息，比如：</p><ul><li><code>[PARENT]</code>用于存储父视图。在处理特定视图时，Ivy 将<code>viewData</code>设置为该<code>LView</code>；完成该视图的处理后，将<code>viewData</code>设置回原始<code>viewData</code>之前的状态（父<code>LView</code>）</li><li><code>[NEXT]</code>用来链接组件视图和跨容器的视图</li><li><code>[T_HOST]</code>存储当前<code>LView</code>插入位置的<code>TNode</code>，因为“子级”除了插入到“父级”中，还可以插入到任何地方，因此不能将插入信息存储在<code>TView</code>中</li><li><code>[DECLARATION_VIEW]</code>用于存储“声明视图”（声明模板的视图），因为动态创建的视图的模板可以在与插入的视图不同的视图中声明，因此，上下文应继承自声明视图树，而不是插入视图树</li><li><code>[CHILD_HEAD]</code>存储引用层次结构中此<code>LView</code>下的第一个<code>LView</code>或<code>LContainer</code>，以便视图可以遍历其嵌套视图以除去侦听器并调用<code>onDestroy</code>回调</li><li><code>[CHILD_TAIL]</code>存储层次结构中此<code>LView</code>下的最后一个<code>LView</code>或<code>LContainer</code>，尾部使 Ivy 可以快速向视图列表的末尾添加新状态，而不必从第一个孩子开始传播</li></ul><p><code>LView</code>的设计，可以为每个视图保留单独的状态以方便视图的插入/删除，因此我们不必根据存在的视图来编辑数据数组。</p><h3 id="LView-TView-data-数据视图"><a href="#LView-TView-data-数据视图" class="headerlink" title="LView/TView.data 数据视图"></a>LView/TView.data 数据视图</h3><p>在 Ivy 中，<code>LView</code>和<code>TView.data</code>都是数组，它们的索引指向相同的项目。它们的数据视图布局如下：</p><table><thead><tr><th>Section</th><th><code>LView</code></th><th><code>TView.data</code></th></tr></thead><tbody><tr><td><code>HEADER</code></td><td>上下文数据</td><td>大多数为<code>null</code></td></tr><tr><td><code>DECLS</code></td><td>DOM、pipe 和本地引用实例</td><td></td></tr><tr><td><code>VARS</code></td><td>绑定值</td><td>属性名称</td></tr><tr><td><code>EXPANDO</code></td><td>host bindings; directive instances; providers; dynamic nodes</td><td>host prop names; directive tokens; provider tokens; <code>null</code></td></tr></tbody></table><p>其中：</p><ul><li><code>HEADER</code>是一个固定的数组大小，其中包含有关模板的上下文信息。主要是诸如父级<code>LView`</code>Sanitizer <code>、</code>TView`之类的信息，以及模板渲染所需的更多信息</li><li><code>DECKS</code>包含 DOM 元素、管道实例和本地引用，<code>DECKS</code>节的大小在组件定义的属性<code>decl</code>中声明</li><li><code>VARS</code>包含有关如何处理绑定的信息，<code>VARS</code>部分的大小在组件定义的属性<code>var</code>中声明</li><li><code>EXPANDO</code>包含有关在编译时未知大小的数据的信息。比如<code>Component/Directives</code>，因为 Ivy 在编译时不知道会匹配哪些指令</li></ul><p>至于具体的例子这里便不展开介绍了，你可以从 <a href="https://github.com/angular/angular/blob/master/packages/core/src/render3/VIEW_DATA.md" target="_blank" rel="noopener">DOCS: View Data Explanation</a> 文档中找到。</p><h2 id="Ivy-中-的-DI"><a href="#Ivy-中-的-DI" class="headerlink" title="Ivy 中 的 DI"></a>Ivy 中 的 DI</h2><p>在 Angular DI 中，注入器获取对应的示例依赖于 token 令牌。Ivy 将所有令牌存储在<code>TView.data</code>中，将实例存储在<code>LView</code>中，因此我们可以检索查看该视图的所有注入器。</p><p>而 DI 查找依赖的过程，离不开<code>NodeInjector</code>。</p><h3 id="NodeInjector"><a href="#NodeInjector" class="headerlink" title="NodeInjector"></a>NodeInjector</h3><p><a href>上一节中</a>，我们介绍了 Ivy 编译器中使用增量编译来优化构建速度，增量编译意味着一个库只会根据变更的部分进行重新编译。要做到增量编译，Ivy 编译器不得依赖未直接传递给它的任何输入（可理解为“纯函数”）。使用<code>Lview</code>来存储每个视图的状态和数据，则可以通过 DI 注入依赖的视图数据。</p><p>在<a href="https://godbasin.github.io/2021/07/11/angular-design-di-2-hierarchical-di/">《Angular 框架解读–多级依赖注入设计》</a>一文中，我们介绍了 Angular 中的两种注入器：模块注入器<code>ModuleInjector</code>和元素注入器<code>ElementInjector</code>。Angular 通过依次遍历元素注入器树和模块注入器树来查找提供令牌的注入器。</p><p>实际上，在 Ivy 中使用<code>NodeInjector</code>替换了 View Engine 中的元素注入器：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> NodeInjector <span class="keyword">implements</span> Injector &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> _tNode:</span></span><br><span class="line"><span class="params">      | TElementNode</span></span><br><span class="line"><span class="params">      | TContainerNode</span></span><br><span class="line"><span class="params">      | TElementContainerNode</span></span><br><span class="line"><span class="params">      | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> _lView: LView</span></span><br><span class="line"><span class="params">  </span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span>(token: <span class="built_in">any</span>, notFoundValue?: <span class="built_in">any</span>): <span class="built_in">any</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getOrCreateInjectable(</span><br><span class="line">      <span class="keyword">this</span>._tNode,</span><br><span class="line">      <span class="keyword">this</span>._lView,</span><br><span class="line">      token,</span><br><span class="line">      <span class="literal">undefined</span>,</span><br><span class="line">      notFoundValue</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>getOrCreateInjectable</code>方法从<code>NodeInjectors</code>到<code>ModuleInjector</code>进行遍历，并返回（或创建）与给定令牌关联的值。</p><h3 id="DI-查找依赖的过程"><a href="#DI-查找依赖的过程" class="headerlink" title="DI 查找依赖的过程"></a>DI 查找依赖的过程</h3><p>我们知道 Angular 会构建一棵视图树，该视图树总是以只含一个根元素的伪根视图开始（参考<a href="https://godbasin.github.io/2021/04/05/angular-design-dom-define/">《Angular 框架解读–视图抽象定义》</a>）。</p><p>Ivy 使用<code>LView</code>和<code>TView.data</code>数组来存储视图数据，其中便包括了节点的注入信息。这意味着，<strong><code>NodeInjector</code>需要从<code>LView</code>和<code>TView.data</code>数组中得到具体的视图数据信息</strong>。</p><p>我们可以从<code>getOrCreateInjectable</code>中看到该过程：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getOrCreateInjectable</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  tNode: TDirectiveHostNode | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  lView: LView,</span></span></span><br><span class="line"><span class="function"><span class="params">  token: Type&lt;T&gt; | AbstractType&lt;T&gt; | InjectionToken&lt;T&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  flags: InjectFlags = InjectFlags.Default,</span></span></span><br><span class="line"><span class="function"><span class="params">  notFoundValue?: <span class="built_in">any</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">T</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (tNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> bloomHash = bloomHashBitOrFactory(token);</span><br><span class="line">    <span class="comment">// 如果此处存储的 ID 是一个函数，则这是一个特殊的对象，例如 ElementRef 或 TemplateRef</span></span><br><span class="line">    <span class="comment">// 因此只需调用 factory 函数即可创建它</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> bloomHash === <span class="string">"function"</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!enterDI(lView, tNode, flags)) &#123;</span><br><span class="line">        <span class="comment">// 无法进入 DI，则尝试使用模块注入器</span></span><br><span class="line">        <span class="comment">// 如果使用 @Host 标志注入令牌，则在 Ivy 中不会在模块注入器中搜索该令牌</span></span><br><span class="line">        <span class="keyword">return</span> flags &amp; InjectFlags.Host</span><br><span class="line">          ? notFoundValueOrThrow&lt;T&gt;(notFoundValue, token, flags)</span><br><span class="line">          : lookupTokenUsingModuleInjector&lt;T&gt;(</span><br><span class="line">              lView,</span><br><span class="line">              token,</span><br><span class="line">              flags,</span><br><span class="line">              notFoundValue</span><br><span class="line">            );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> value = bloomHash(flags);</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span> &amp;&amp; !(flags &amp; InjectFlags.Optional)) &#123;</span><br><span class="line">          throwProviderNotFoundError(token);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        leaveDI();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> bloomHash === <span class="string">"number"</span>) &#123;</span><br><span class="line">      <span class="comment">// 对遍历元素注入器树时找到的上一个注入器 TView 的引用</span></span><br><span class="line">      <span class="comment">// 这用于了解是否可以在当前注射器上访问 viewProviders</span></span><br><span class="line">      <span class="keyword">let</span> previousTView: TView | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">let</span> injectorIndex = getInjectorIndex(tNode, lView);</span><br><span class="line">      <span class="keyword">let</span> parentLocation: RelativeInjectorLocation = NO_PARENT_INJECTOR;</span><br><span class="line">      <span class="keyword">let</span> hostTElementNode: TNode | <span class="literal">null</span> =</span><br><span class="line">        flags &amp; InjectFlags.Host</span><br><span class="line">          ? lView[DECLARATION_COMPONENT_VIEW][T_HOST]</span><br><span class="line">          : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果我们应该跳过此注入器，或者此节点上没有注入器，需先搜索父注入器</span></span><br><span class="line">      <span class="keyword">if</span> (injectorIndex === <span class="number">-1</span> || flags &amp; InjectFlags.SkipSelf) &#123;</span><br><span class="line">        parentLocation =</span><br><span class="line">          injectorIndex === <span class="number">-1</span></span><br><span class="line">            ? getParentInjectorLocation(tNode, lView)</span><br><span class="line">            : lView[injectorIndex + NodeInjectorOffset.PARENT];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">          parentLocation === NO_PARENT_INJECTOR ||</span><br><span class="line">          !shouldSearchParent(flags, <span class="literal">false</span>)</span><br><span class="line">        ) &#123;</span><br><span class="line">          injectorIndex = <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          previousTView = lView[TVIEW];</span><br><span class="line">          injectorIndex = getParentInjectorIndex(parentLocation);</span><br><span class="line">          lView = getParentInjectorView(parentLocation, lView);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 遍历注入器树，直到找到潜​​在的匹配项，或者直到知道*不是*匹配项为止。</span></span><br><span class="line">      <span class="keyword">while</span> (injectorIndex !== <span class="number">-1</span>) &#123;</span><br><span class="line">        ngDevMode &amp;&amp; assertNodeInjector(lView, injectorIndex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查当前的注入器。如果匹配，请查看它是否包含令牌</span></span><br><span class="line">        <span class="keyword">const</span> tView = lView[TVIEW];</span><br><span class="line">        ngDevMode &amp;&amp;</span><br><span class="line">          assertTNodeForLView(</span><br><span class="line">            tView.data[injectorIndex + NodeInjectorOffset.TNODE] <span class="keyword">as</span> TNode,</span><br><span class="line">            lView</span><br><span class="line">          );</span><br><span class="line">        <span class="keyword">if</span> (bloomHasToken(bloomHash, injectorIndex, tView.data)) &#123;</span><br><span class="line">          <span class="comment">// 在这一点上，我们有一个*可能*包含令牌的注入器</span></span><br><span class="line">          <span class="comment">// 因此我们逐步浏览与注入器的相应节点相关联的提供程序和指令以获取实例</span></span><br><span class="line">          <span class="keyword">const</span> instance: T | <span class="literal">null</span> = searchTokensOnInjector&lt;T&gt;(</span><br><span class="line">            injectorIndex,</span><br><span class="line">            lView,</span><br><span class="line">            token,</span><br><span class="line">            previousTView,</span><br><span class="line">            flags,</span><br><span class="line">            hostTElementNode</span><br><span class="line">          );</span><br><span class="line">          <span class="keyword">if</span> (instance !== NOT_FOUND) &#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        parentLocation = lView[injectorIndex + NodeInjectorOffset.PARENT];</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">          parentLocation !== NO_PARENT_INJECTOR &amp;&amp;</span><br><span class="line">          shouldSearchParent(</span><br><span class="line">            flags,</span><br><span class="line">            lView[TVIEW].data[injectorIndex + NodeInjectorOffset.TNODE] ===</span><br><span class="line">              hostTElementNode</span><br><span class="line">          ) &amp;&amp;</span><br><span class="line">          bloomHasToken(bloomHash, injectorIndex, lView)</span><br><span class="line">        ) &#123;</span><br><span class="line">          <span class="comment">// 在此节点上的任何位置都找不到 def，因此它是误报。遍历树并继续搜索</span></span><br><span class="line">          previousTView = tView;</span><br><span class="line">          injectorIndex = getParentInjectorIndex(parentLocation);</span><br><span class="line">          lView = getParentInjectorView(parentLocation, lView);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 如果我们不应该搜索父对象，或者如果祖先的 bloom 过滤器值没有对应于该指令的位</span></span><br><span class="line">          <span class="comment">// 我们可以放弃遍历以查找特定的注入器</span></span><br><span class="line">          injectorIndex = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> lookupTokenUsingModuleInjector&lt;T&gt;(lView, token, flags, notFoundValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码中，如果我们调用<code>injector.get(SomeClass)</code>方法，会产生以下步骤：</p><ol><li>Angular 在<code>SomeClass.__NG_ELEMENT_ID__</code>静态属性中查找哈希。</li><li>如果该哈希是工厂函数，则还有另一种特殊情况，即应通过调用该函数来初始化对象。</li><li>如果该哈希等于-1，则是一种特殊情况，我们将获得<code>NodeInjector</code>实例。</li><li>如果该哈希是一个数字，那么我们会从<code>TNode</code>获取<code>injectorIndex</code>。</li><li>查看模板布隆过滤器（<code>TView.data [injectorIndex]</code>），如果为真，那么我们将搜索<code>SomeClass</code>令牌（通过<code>tNode.providerIndexes</code>可以找到所需的令牌）。</li><li>如果模板布隆过滤器返回错误，那么会查看一下累积布隆过滤器。如果它为真，则继续进行遍历，否则将切换到<code>ModuleInjector</code>。</li></ol><p>该过程可以用以下流程图表示：</p><p><img src="https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/angular-ivy-2-2.png" alt></p><p>这便是在 Ivy 中，使用<code>NodeInjector</code>来解析依赖关系的过程。可以看到，该过程中还使用了两个布隆过滤器：累积布隆过滤器（cumulativeBloom）和模板布隆过滤器（templateBloom）。</p><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>布隆过滤器常用于加快数据检索的过程，属于哈希函数的一种，你可以阅读 <a href="https://hackernoon.com/probabilistic-data-structures-bloom-filter-5374112a7832" target="_blank" rel="noopener">Probabilistic Data structures: Bloom filter</a> 一文来了解它。</p><p>在 Ivy 中，一个视图可以具有与为该视图上的节点创建的注入器数量一样多的布隆过滤器。下图为可视化结果：</p><p><img src="https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/angular-ivy-2-1.png" alt></p><p>可以看到，布隆过滤器存储在前面提到的<code>LView/TView.data</code>布局中的<code>EXPANDO</code>部分:</p><ul><li><code>LView</code>和<code>TView.data</code>数组可以包含许多布隆过滤器，长度为 8 个时隙（[n，n + 7]索引），它们的数量与为其创建喷射器的节点数量成正比</li><li>每个布隆过滤器在“压缩的”<code>parentLocation</code>插槽（n + 8 索引）中都有一个指向父布隆过滤器的指针</li></ul><p>我们结合<code>NodeInjector</code>中查找依赖的过程，以以下简单的代码为例：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">"my-app"</span>,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div dirA&gt;</span></span><br><span class="line"><span class="string">      &lt;div dirB&gt;Hello Ivy&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppComponent &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Directive</span>(&#123; selector: <span class="string">"[dirA]"</span> &#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> DirA &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Directive</span>(&#123; selector: <span class="string">"[dirB]"</span> &#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> DirB &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> rootComp: AppComponent</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Ivy 中，上述代码会生成这样的可视化视图：</p><p><img src="https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/angular-ivy-2-3.png" alt></p><p>Ivy 在<code>TNode</code>上创建了<code>InjectorIndex</code>属性，以便知道专用于此节点布隆过滤器的位置。除此之外，Ivy 还在<code>LView</code>数组中存储了<code>parentLocation</code>指针，以便我们可以遍历所有父注入器。</p><p>而我们也看到，<code>NodeInjector</code>是具有对<code>TNode</code>和<code>LView</code>对象的引用的对象。因此，每个<code>NodeInjector</code>分别保存在<code>LView</code>的 9 个连续插槽和<code>TView.data</code>的 9 个连续插槽中，如图：</p><p><img src="https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/angular-ivy-2-4.png" alt></p><p>那么，上面简单的代码示例中，DI 查找依赖的过程如图：</p><p><img src="https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/angular-ivy-2-5.png" alt></p><blockquote><p>以上例子来自于 <a href="https://indepth.dev/posts/1268/angular-di-getting-to-know-the-ivy-nodeinjector" target="_blank" rel="noopener">Angular DI: Getting to know the Ivy NodeInjector</a></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天给大家介绍了 Ivy 编译器中的数据视图<code>LView/TView</code>，而依赖解析过程中需要从中取出对应的数据，该过程使用到<code>NodeInjector</code>。<code>NodeInjector</code>用于创建注入器，为了加快 DI 搜索依赖的过程，Ivy 还设计了累加布隆过滤器和模板布隆过滤器。</p><p>这些内容，是理解 Angular 中依赖注入过程中不可或缺的。而在查阅这部分文章和代码之前，我甚至无法想象在 Angular 中依赖注入过程如此复杂。很多时候，我们都认为前端领域并不存在太多的算法和数据结构相关的内容，实际上可能只是我们并没有接触到而已。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://indepth.dev/posts/1268/angular-di-getting-to-know-the-ivy-nodeinjector" target="_blank" rel="noopener">Angular DI: Getting to know the Ivy NodeInjector</a></li><li><a href="https://github.com/angular/angular/blob/master/packages/core/src/render3/VIEW_DATA.md" target="_blank" rel="noopener">DOCS: View Data Explanation</a></li><li><a href="https://hackernoon.com/probabilistic-data-structures-bloom-filter-5374112a7832" target="_blank" rel="noopener">Probabilistic Data structures: Bloom filter</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为“为大型前端项目”而设计的前端框架，Angular 其实有许多值得参考和学习的设计，本系列主要用于研究这些设计和功能的实现原理。本文主要介绍在 Angular 的 Ivy 编译器中，是如何管理和查找视图数据的。&lt;/p&gt;
    
    </summary>
    
      <category term="Angular源码" scheme="https://godbasin.github.io/categories/Angular%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="功能设计" scheme="https://godbasin.github.io/tags/%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Angular框架解读--Ivy编译器整体设计</title>
    <link href="https://godbasin.github.io/2021/08/15/angular-design-ivy-0-design/"/>
    <id>https://godbasin.github.io/2021/08/15/angular-design-ivy-0-design/</id>
    <published>2021-08-15T05:53:34.000Z</published>
    <updated>2021-08-15T06:53:55.644Z</updated>
    
    <content type="html"><![CDATA[<p>作为“为大型前端项目”而设计的前端框架，Angular 其实有许多值得参考和学习的设计，本系列主要用于研究这些设计和功能的实现原理。本文围绕 Angular 的核心功能 Ivy 编译器，首先介绍该编译器的整体设计。</p><a id="more"></a><p>对于前端框架来说，模板编译器（渲染器）属于非常核心的能力了。在 Angular 8.0 中引入了一个新的模板编译器——Ivy 编译器，在这之前 Angular 一直使用 View Engine 来编译模板。</p><h2 id="Ivy-编译器能力"><a href="#Ivy-编译器能力" class="headerlink" title="Ivy 编译器能力"></a>Ivy 编译器能力</h2><p>编译器的用途，基本上是将开发者编写的代码，编译成可在浏览器中运行的代码。使用了编译器之后，前端框架就可以定义很多自身的语法，在编译过程可以给代码增加一些性能优化、安全检测等功能。对于 Angular 来说，编译器还需要支持将开发者代码编译成 AOT 和 JIT 两种。</p><p>Angular 重构编译器并将之命名为 Ivy 编译器，这对于 Angular 框架来说有着非常重要的意义，有点类似于 React 重构 Fiber。</p><h3 id="Ivy-新特性"><a href="#Ivy-新特性" class="headerlink" title="Ivy 新特性"></a>Ivy 新特性</h3><p>我们先来看看 Ivy 编译器的一些特性，包括但不限于以下的内容：</p><ul><li>🚀 缩短构建时间（增加增量编译）</li><li>🔥 达到更好的构建大小（生成的代码和 Tree-shaking 更兼容），有效地降低代码包大小</li><li>🔓 解锁新的潜在功能（元编程或更高级别的组件，支持组件的延迟加载，支持不基于 zone.js 的新变更检测系统，等等）</li></ul><p>前面章节中我们有介绍 Angular 的<a href="https://godbasin.github.io/2021/03/27/angular-design-metadata/">元编程</a>、组件和模块之间的关系、<a href="https://godbasin.github.io/2021/05/01/angular-design-zonejs/">zone.js 中的设计</a>和<a href="https://godbasin.github.io/2021/05/30/angular-design-zone-ngzone/">引入</a>等内容，其中不少能力和设计都无法与 Ivy 编译器的设计和引入脱离关系。比如，<a href="https://godbasin.github.io/2021/07/11/angular-design-di-2-hierarchical-di/">Angular 依赖设计</a>中由于延迟模块引入的 bug，前面我们说过 Angular 中的依赖注入通过将注入器分为元素注入器和模块注入器，而在 Ivy 编译器中，使用了支持到组件级别的延迟加载（Node ），最终解决了延迟模块重复加载的问题。</p><p>今天我们先来了解一下 Ivy 编译器的整体设计，后面会再分具体的章节来详细介绍内部的一些源码实现。</p><h2 id="Ivy-架构设计"><a href="#Ivy-架构设计" class="headerlink" title="Ivy 架构设计"></a>Ivy 架构设计</h2><p>在 Angular 中，开发者编写的代码大多数为 Typescript 代码，其中还包括了许多 Angular 提供的 API 和语法糖，因此 Angular 需要通过语法解析转换为 AST，并根据 AST 编译成最终可以跑在浏览器中的代码，这便是 Ivy 编译器需要实现的核心能力。</p><p>Ivy 编译器主要包括两部分：</p><ol><li><code>ngtsc</code>是一个 Typescript-to-Javascript 编译器，它将 Angular 装饰器化为静态属性。它是一个最小包装器，包裹在<code>tsc</code>之外，而<code>tsc</code>中则包含一系列的 Angular 变换。</li><li><code>ngcc</code>主要负责处理来自 NPM 的代码并生成等效的 Ivy 版本，就像使用<code>ngtsc</code>编译代码一样。</li></ol><h3 id="模板编译"><a href="#模板编译" class="headerlink" title="模板编译"></a>模板编译</h3><p>在 Ivy 编译器中使用<code>TemplateCompiler</code>来编译模板，该过程中会执行以下操作：</p><ol><li>标记模板。</li><li>将标记内容解析为 HTML AST。</li><li>将 HTML AST 转换为 Angular 模板 AST。</li><li>将 Angular 模板 AST 转换为模板函数。</li></ol><p>Angular Template AST 转换和注释的 HTML AST 版本时，会执行以下操作：</p><ol><li>将 Angular 模板语法快捷方式（例如<code>*ngFor</code>和<code>[name]</code>）转换为其规范版本（和<code>bind-name</code>）。</li><li>收集引用（<code>#</code>属性）和变量（<code>let-</code>属性）。</li><li>使用收集的变量和引用，解析并转换绑定表达式 AST 中的绑定表达式。</li></ol><p>除了以上操作之外，该过程还会生成详尽的选择器目标列表，包括任何组件、指令或管道的选择器的潜在目标。确定组件包含它所依赖的组件、指令和管道的列表，可在运行时知道将哪些组件和指令应用于元素以及绑定表达式引用了哪些管道。从而<code>TemplateCompiler</code>可以从字符串生成模板函数，而无需附加信息。</p><p>确定此列表的过程称为引用反转，因为它将从模块（包含依赖项）到组件的链接反转为从组件到其依赖项的链接。然后，程序只需要包含呈现的初始组件所依赖的类型以及这些依赖项所需的任何类型。除此之外，还解决了 tree-shaking 的问题。</p><h3 id="Typescript-解析器"><a href="#Typescript-解析器" class="headerlink" title="Typescript 解析器"></a>Typescript 解析器</h3><p>要实现 AST 的解析和转换，离不开解析器。对于 Typescript 代码来说，编译器的整体流程为：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">                                                                |<span class="string">------------</span>|</span><br><span class="line">                           |<span class="string">----------------------------------&gt; </span>|<span class="string"> TypeScript </span>|</span><br><span class="line">                           |<span class="string">                                    </span>|<span class="string">   .d.ts    </span>|</span><br><span class="line">                           |<span class="string">                                    </span>|<span class="string">------------</span>|</span><br><span class="line">                           |</span><br><span class="line">|<span class="string">------------</span>|<span class="string">          </span>|<span class="string">-----</span>|<span class="string">               </span>|<span class="string">-----</span>|<span class="string">           </span>|<span class="string">------------</span>|</span><br><span class="line">|<span class="string"> TypeScript </span>|<span class="string"> -parse-&gt; </span>|<span class="string"> AST </span>|<span class="string"> -&gt;transform-&gt; </span>|<span class="string"> AST </span>|<span class="string"> -&gt;print-&gt; </span>|<span class="string"> JavaScript </span>|</span><br><span class="line">|<span class="string">   source   </span>|<span class="string">    </span>|<span class="string">     </span>|<span class="string">-----</span>|<span class="string">       </span>|<span class="string">       </span>|<span class="string">-----</span>|<span class="string">           </span>|<span class="string">   source   </span>|</span><br><span class="line">|<span class="string">------------</span>|<span class="string">    </span>|<span class="string">        </span>|<span class="string">          </span>|<span class="string">                         </span>|<span class="string">------------</span>|</span><br><span class="line">                  |<span class="string">    type-check     </span>|</span><br><span class="line">                  |<span class="string">        </span>|<span class="string">          </span>|</span><br><span class="line">                  |<span class="string">        v          </span>|</span><br><span class="line">                  |<span class="string">    </span>|<span class="string">--------</span>|<span class="string">     </span>|</span><br><span class="line">                  |<span class="string">--&gt; </span>|<span class="string"> errors </span>|<span class="string"> &lt;---</span>|</span><br><span class="line">                       |<span class="string">--------</span>|</span><br></pre></td></tr></table></figure><p>其中，解析步骤是传统的递归下降解析器，经过增强以支持增量解析，该解析器发出抽象语法树（AST）。转换步骤是一组 AST 到 AST 的转换，这些转换执行各种任务，例如删除类型声明，将模块和类声明降低到 ES5，将<code>async</code>方法转换为状态机等。</p><h3 id="编译器设计"><a href="#编译器设计" class="headerlink" title="编译器设计"></a>编译器设计</h3><p>前面我们提到 Ivy 支持增量编译，从而达到缩短构建时间的效果。增量编译的预期是当一个库已经被编译时，我们就不必每次都重新编译它，而是根据变更的部分进行重新编译。这看起来比较简单，实际上它对编译器提供了不小的挑战，因为组件的生成代码可能会使用另一个组件的内部细节。</p><p>从广义上讲，Ivy 模型是将 Angular 装饰器编译为类上的静态属性，包括：</p><ul><li>组件编译（<code>ViewCompiler</code>和样式编译器）：编译<code>@Component</code> =&gt; <code>ɵɵdefineComponent</code></li><li>管道编译<code>PipeCompiler</code>：编译<code>@Pipe</code>=&gt;<code>ɵɵdefinePipe</code></li><li>指令编译<code>DirectiveCompiler</code>：编译<code>@Directive</code>=&gt;<code>ɵɵdefineDirective</code></li><li>可注入编译<code>InjectableCompiler</code>：编译<code>@Injectable</code>=&gt;<code>ɵɵdefineInjectable</code></li><li>模块编译<code>NgModuleCompiler</code>：编译<code>@NgModule</code>=&gt;<code>ɵɵdefineInjector</code>（<code>ɵɵdefineNgModule</code>仅在 JIT 中）</li></ul><p>这些操作必须在没有全局程序数据的情况下进行，并且在大多数情况下，仅在具有单个装饰器数据的情况下进行。</p><p>因此，Ivy 编译器不得依赖未直接传递给它的任何输入（例如，它不得扫描源或元数据中的其他数据）。该限制很重要，原因有两个：</p><ol><li>由于可以看到编译器的所有输入，因此它有助于强制执行 Ivy 局部性原则。</li><li>它可以防止在<code>--watch</code>模式下进行错误的构建，因为文件之间的依赖关系很容易跟踪。</li></ol><p>所以在 Ivy 中，每个将单个装饰器转换为静态字段的“编译器”都将充当“纯函数”。给定有关特定类型和装饰器的输入元数据，它将生成一个对象，该对象描述要添加到该类型的字段，以及该字段的初始化值（采用 AST 格式）。</p><p>举个例子，<code>@Component</code>编译器的输入包括以下内容：</p><ul><li>对组件类的引用</li><li>组件的模板和样式资源</li><li>组件的选择器</li><li>组件所属模块的选择器映射</li></ul><h3 id="Ivy-编译模型"><a href="#Ivy-编译模型" class="headerlink" title="Ivy 编译模型"></a>Ivy 编译模型</h3><p>在 Angular 中，实例化组件、创建 DOM 节点以及运行变更检测，以上的逻辑被实现为一个原子单位，被称为“Angular 解释器”。编译器仅生成有关其模板中定义的组件和元素的元数据。</p><p>在旧版 View Engine 中，编译过程为：</p><p><img src="https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/angular-ivy-1-1.png" alt></p><p><code>&lt;span&gt;My name is &lt;/span&gt;</code>这句模板代码，编译后的代码大概长这个样子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">viewDef(<span class="number">0</span>,[</span><br><span class="line">    elementDef(<span class="number">0</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">1</span>,<span class="string">'span'</span>,...),</span><br><span class="line">    textDef(<span class="literal">null</span>,[<span class="string">'My name is '</span>,...])</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>而在 Ivy 编译器中，编译后的代码大概长这个样子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create mode</span></span><br><span class="line"><span class="keyword">if</span> (rf &amp; RenderFlags.Create) &#123;</span><br><span class="line">  elementStart(<span class="number">0</span>, <span class="string">"span"</span>);</span><br><span class="line">  text(<span class="number">1</span>);</span><br><span class="line">  elementEnd();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// update mode</span></span><br><span class="line"><span class="keyword">if</span> (rf &amp; RenderFlags.Update) &#123;</span><br><span class="line">  textBinding(<span class="number">1</span>, interpolation1(<span class="string">"My name is"</span>, ctx.name));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Ivy 编译器中，编译过程为：</p><p><img src="https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/angular-ivy-1-2.png" alt></p><p>在 View Engine 中，组件定义（模板数据）独立于组件类而位于其自己的文件中。而在 Ivy 编译器中，组件定义将通过静态字段附加到组件类，编译期间不会创建单独的文件。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天大致介绍了 Angular 中 Ivy 编译器的整体设计，其实 Angular 本身就对 Ivy 编译器的整体架构提供了很详细的说明，本文很多内容也都参考来自这些内容，建议大家可以都去看看 <a href="https://github.com/angular/angular/blob/master/packages/compiler/design/architecture.md" target="_blank" rel="noopener">DESIGN DOC(Ivy): Compiler Architecture</a>。</p><p>Ivy 编译器作为 Angular 的核心能力，并不是一篇文章足以概括完毕。本文也并未介绍<code>ngtsc</code>的编译流程、资源加载等内容，也并未开始结合 Angular 中的源码一起研究其实现。这些我后续会尝试一点一点地挖掘，希望能从中学到架构文档以外更多的知识，我也会尝试将自己的学习过程记录下来，继续分享给对 Angular 感兴趣的你们~~</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://github.com/angular/angular/blob/master/packages/compiler/design/architecture.md" target="_blank" rel="noopener">DESIGN DOC(Ivy): Compiler Architecture</a></li><li><a href="https://indepth.dev/posts/1259/angular-compatability-compiler" target="_blank" rel="noopener">Under the hood of the Angular Compatibility Compiler (ngcc)</a></li><li><a href="https://blog.ninja-squad.com/2019/05/07/what-is-angular-ivy/" target="_blank" rel="noopener">What is Angular Ivy?</a></li><li><a href="https://medium.com/angular-in-depth/all-you-need-to-know-about-ivy-the-new-angular-engine-9cde471f42cf" target="_blank" rel="noopener">All you need to know about Ivy, The new Angular engine!</a></li><li><a href="https://indepth.dev/posts/1062/ivy-engine-in-angular-first-in-depth-look-at-compilation-runtime-and-change-detection" target="_blank" rel="noopener">Ivy engine in Angular: first in-depth look at compilation, runtime and change detection</a></li><li><a href="https://indepth.dev/posts/1053/everything-you-need-to-know-about-change-detection-in-angular" target="_blank" rel="noopener">Everything you need to know about change detection in Angular</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为“为大型前端项目”而设计的前端框架，Angular 其实有许多值得参考和学习的设计，本系列主要用于研究这些设计和功能的实现原理。本文围绕 Angular 的核心功能 Ivy 编译器，首先介绍该编译器的整体设计。&lt;/p&gt;
    
    </summary>
    
      <category term="Angular源码" scheme="https://godbasin.github.io/categories/Angular%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="功能设计" scheme="https://godbasin.github.io/tags/%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Angular框架解读--依赖注入的引导过程</title>
    <link href="https://godbasin.github.io/2021/07/25/angular-design-di-3-bootstrap/"/>
    <id>https://godbasin.github.io/2021/07/25/angular-design-di-3-bootstrap/</id>
    <published>2021-07-25T05:55:21.000Z</published>
    <updated>2021-07-25T06:43:59.545Z</updated>
    
    <content type="html"><![CDATA[<p>作为“为大型前端项目”而设计的前端框架，Angular 其实有许多值得参考和学习的设计，本系列主要用于研究这些设计和功能的实现原理。本文主要围绕 Angular 中的最大特点——依赖注入，介绍 Angular 依赖注入在体系在应用引导过程中的的设计和实现。</p><a id="more"></a><p><a href="https://godbasin.github.io/2021/07/11/angular-design-di-2-hierarchical-di/">多级依赖注入</a>中，介绍了模块注入器和元素注入器两种层次结构的注入器。那么，Angular 在引导过程中，又是如何初始化根模块和入口组件的呢？</p><h1 id="Angular-的引导过程"><a href="#Angular-的引导过程" class="headerlink" title="Angular 的引导过程"></a>Angular 的引导过程</h1><p>前面我们说到，Angular 应用在浏览器中引导时，会创建浏览器平台，并引导根模块：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">platformBrowserDynamic().bootstrapModule(AppModule);</span><br></pre></td></tr></table></figure><h2 id="引导根模块"><a href="#引导根模块" class="headerlink" title="引导根模块"></a>引导根模块</h2><h3 id="根模块-AppModule"><a href="#根模块-AppModule" class="headerlink" title="根模块 AppModule"></a>根模块 AppModule</h3><p>在 Angular 中，每个应用有至少一个 Angular 模块，根模块就是你用来引导此应用的模块，它通常命名为 AppModule。</p><p>当你使用 Angular CLI 命令 ng new 生成一个应用时，其默认的 AppModule 是这样的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BrowserModule &#125; <span class="keyword">from</span> <span class="string">'@angular/platform-browser'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; NgModule &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; AppComponent &#125; <span class="keyword">from</span> <span class="string">'./app.component'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  declarations: [</span><br><span class="line">    AppComponent</span><br><span class="line">  ],</span><br><span class="line">  imports: [</span><br><span class="line">    BrowserModule</span><br><span class="line">  ],</span><br><span class="line">  providers: [],</span><br><span class="line">  bootstrap: [AppComponent]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppModule &#123; &#125;</span><br></pre></td></tr></table></figure><h3 id="引导根模块的过程"><a href="#引导根模块的过程" class="headerlink" title="引导根模块的过程"></a>引导根模块的过程</h3><p>我们来看看平台层引导根模块的过程中都做了些什么：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> PlatformRef &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  bootstrapModuleFactory&lt;M&gt;(moduleFactory: NgModuleFactory&lt;M&gt;, options?: BootstrapOptions):</span><br><span class="line">      <span class="built_in">Promise</span>&lt;NgModuleRef&lt;M&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// 由于实例化模块时，会需要创建一些提供者，所以这里需要在实例化模块之前创建 NgZone</span></span><br><span class="line">    <span class="comment">// 因此，这里创建了一个仅包含新 NgZone 的微型父注入器，并将其作为父传递给 NgModuleFactory</span></span><br><span class="line">    <span class="keyword">const</span> ngZoneOption = options ? options.ngZone : <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">const</span> ngZoneEventCoalescing = (options &amp;&amp; options.ngZoneEventCoalescing) || <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">const</span> ngZoneRunCoalescing = (options &amp;&amp; options.ngZoneRunCoalescing) || <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">const</span> ngZone = getNgZone(ngZoneOption, &#123;ngZoneEventCoalescing, ngZoneRunCoalescing&#125;);</span><br><span class="line">    <span class="keyword">const</span> providers: StaticProvider[] = [&#123;provide: NgZone, useValue: ngZone&#125;];</span><br><span class="line">    <span class="comment">// ApplicationRef 将在 Angular zone 之外创建</span></span><br><span class="line">    <span class="keyword">return</span> ngZone.run(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 在 ngZone.run 中创建 ngZoneInjector，以便在 Angular zone 中创建所有实例化的服务</span></span><br><span class="line">      <span class="keyword">const</span> ngZoneInjector = Injector.create(</span><br><span class="line">          &#123;providers: providers, parent: <span class="keyword">this</span>.injector, name: moduleFactory.moduleType.name&#125;);</span><br><span class="line">      <span class="keyword">const</span> moduleRef = &lt;InternalNgModuleRef&lt;M&gt;&gt;moduleFactory.create(ngZoneInjector);</span><br><span class="line">      <span class="keyword">const</span> exceptionHandler: ErrorHandler|<span class="literal">null</span> = moduleRef.injector.get(ErrorHandler, <span class="literal">null</span>);</span><br><span class="line">      <span class="keyword">if</span> (!exceptionHandler) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'No ErrorHandler. Is platform module (BrowserModule) included?'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">return</span> _callAndReportToErrorHandler(exceptionHandler, ngZone!, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> initStatus: ApplicationInitStatus = moduleRef.injector.get(ApplicationInitStatus);</span><br><span class="line">        initStatus.runInitializers();</span><br><span class="line">        <span class="keyword">return</span> initStatus.donePromise.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          ...</span><br><span class="line">          <span class="comment">// 引导模块</span></span><br><span class="line">          <span class="keyword">this</span>._moduleDoBootstrap(moduleRef);</span><br><span class="line">          <span class="keyword">return</span> moduleRef;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bootstrapModule&lt;M&gt;(</span><br><span class="line">      moduleType: Type&lt;M&gt;,</span><br><span class="line">      compilerOptions: (CompilerOptions&amp;BootstrapOptions)|</span><br><span class="line">      <span class="built_in">Array</span>&lt;CompilerOptions&amp;BootstrapOptions&gt; = []): <span class="built_in">Promise</span>&lt;NgModuleRef&lt;M&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> options = optionsReducer(&#123;&#125;, compilerOptions);</span><br><span class="line">    <span class="comment">// 编译并创建 @NgModule 的实例</span></span><br><span class="line">    <span class="keyword">return</span> compileNgModuleFactory(<span class="keyword">this</span>.injector, options, moduleType)</span><br><span class="line">        .then(<span class="function"><span class="params">moduleFactory</span> =&gt;</span> <span class="keyword">this</span>.bootstrapModuleFactory(moduleFactory, options));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> _moduleDoBootstrap(moduleRef: InternalNgModuleRef&lt;<span class="built_in">any</span>&gt;): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> appRef = moduleRef.injector.get(ApplicationRef) <span class="keyword">as</span> ApplicationRef;</span><br><span class="line">    <span class="comment">// 引导应用程序</span></span><br><span class="line">    <span class="keyword">if</span> (moduleRef._bootstrapComponents.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 在应用程序的根级别引导新组件</span></span><br><span class="line">      moduleRef._bootstrapComponents.forEach(<span class="function"><span class="params">f</span> =&gt;</span> appRef.bootstrap(f));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (moduleRef.instance.ngDoBootstrap) &#123;</span><br><span class="line">      moduleRef.instance.ngDoBootstrap(appRef);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>._modules.push(moduleRef);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根模块引导时，除了编译并创建 AppModule 的实例，还会创建 NgZone，关于 NgZone 的请参考<a href></a>。在编译和创建 AppModule 的过程中，便会创建<code>ApplicationRef</code>，即 Angular 应用程序。</p><h2 id="引导-Angular-应用程序"><a href="#引导-Angular-应用程序" class="headerlink" title="引导 Angular 应用程序"></a>引导 Angular 应用程序</h2><p>前面在引导根模块过程中，创建了 Angular 应用程序之后，便会在应用程序的根级别引导新组件：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在应用程序的根级别引导新组件</span></span><br><span class="line">moduleRef._bootstrapComponents.forEach(<span class="function"><span class="params">f</span> =&gt;</span> appRef.bootstrap(f));</span><br></pre></td></tr></table></figure><p>我们来看看这个过程会发生什么。</p><h3 id="应用程序-ApplicationRef"><a href="#应用程序-ApplicationRef" class="headerlink" title="应用程序 ApplicationRef"></a>应用程序 ApplicationRef</h3><p>一个 Angular 应用程序，提供了以下的能力：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ApplicationRef &#123;</span><br><span class="line">  <span class="comment">// 获取已注册到该应用程序的组件类型的列表</span></span><br><span class="line">  <span class="keyword">public</span> readonly componentTypes: Type&lt;<span class="built_in">any</span>&gt;[] = [];</span><br><span class="line">  <span class="comment">// 获取已注册到该应用程序的组件的列表</span></span><br><span class="line">  <span class="keyword">public</span> readonly components: ComponentRef&lt;<span class="built_in">any</span>&gt;[] = [];</span><br><span class="line">  <span class="comment">// 返回一个 Observable，指示应用程序何时稳定或不稳定</span></span><br><span class="line">  <span class="comment">// 如果在应用程序引导时，引导任何种类的周期性异步任务，则该应用程序将永远不会稳定（例如轮询过程）</span></span><br><span class="line">  <span class="keyword">public</span> readonly isStable!: Observable&lt;<span class="built_in">boolean</span>&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">      <span class="keyword">private</span> _zone: NgZone, <span class="keyword">private</span> _injector: Injector, <span class="keyword">private</span> _exceptionHandler: ErrorHandler,</span></span><br><span class="line"><span class="params">      <span class="keyword">private</span> _componentFactoryResolver: ComponentFactoryResolver,</span></span><br><span class="line"><span class="params">      <span class="keyword">private</span> _initStatus: ApplicationInitStatus</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建时，主要进行两件事：</span></span><br><span class="line">        <span class="comment">// 1. 宏任务结束后，检测视图是否需要更新。</span></span><br><span class="line">        <span class="comment">// 2. 在 Angular Zone 之外创建对 onStable 的预订，以便在 Angular Zone 之外运行回调。</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在应用程序的根级别引导新组件</span></span><br><span class="line">  bootstrap&lt;C&gt;(componentOrFactory: ComponentFactory&lt;C&gt;|Type&lt;C&gt;, rootSelectorOrNode?: <span class="built_in">string</span>|<span class="built_in">any</span>):</span><br><span class="line">      ComponentRef&lt;C&gt; &#123;&#125;</span><br><span class="line">  <span class="comment">// 调用此方法以显式处理更改检测及其副作用</span></span><br><span class="line">  tick(): <span class="built_in">void</span> &#123;&#125;</span><br><span class="line">  <span class="comment">// 关联视图，以便对其进行脏检查，视图销毁后将自动分离</span></span><br><span class="line">  attachView(viewRef: ViewRef): <span class="built_in">void</span> &#123;&#125;</span><br><span class="line">  <span class="comment">// 再次从脏检查中分离视图</span></span><br><span class="line">  detachView(viewRef: ViewRef): <span class="built_in">void</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，我们来看看<code>bootstrap()</code>过程中，Angular 都做了些什么。</p><h3 id="在应用程序的根级别引导根组件"><a href="#在应用程序的根级别引导根组件" class="headerlink" title="在应用程序的根级别引导根组件"></a>在应用程序的根级别引导根组件</h3><p>将新的根组件引导到应用程序中时，Angular 将指定的应用程序组件安装到由<code>componentType</code>的选择器标识的 DOM 元素上，并引导自动更改检测以完成组件的初始化。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ApplicationRef &#123;</span><br><span class="line">  bootstrap&lt;C&gt;(componentOrFactory: ComponentFactory&lt;C&gt;|Type&lt;C&gt;, rootSelectorOrNode?: <span class="built_in">string</span>|<span class="built_in">any</span>):</span><br><span class="line">      ComponentRef&lt;C&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 如果未与其他模块绑定，则创建与当前模块关联的工厂</span></span><br><span class="line">    <span class="keyword">const</span> ngModule =</span><br><span class="line">        isBoundToModule(componentFactory) ? <span class="literal">undefined</span> : <span class="keyword">this</span>._injector.get(NgModuleRef);</span><br><span class="line">    <span class="keyword">const</span> selectorOrNode = rootSelectorOrNode || componentFactory.selector;</span><br><span class="line">    <span class="comment">// 创建组件</span></span><br><span class="line">    <span class="keyword">const</span> compRef = componentFactory.create(Injector.NULL, [], selectorOrNode, ngModule);</span><br><span class="line">    <span class="keyword">const</span> nativeElement = compRef.location.nativeElement;</span><br><span class="line">    <span class="comment">// 创建可测试服务挂钩</span></span><br><span class="line">    <span class="keyword">const</span> testability = compRef.injector.get(Testability, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">const</span> testabilityRegistry = testability &amp;&amp; compRef.injector.get(TestabilityRegistry);</span><br><span class="line">    <span class="keyword">if</span> (testability &amp;&amp; testabilityRegistry) &#123;</span><br><span class="line">      testabilityRegistry.registerApplication(nativeElement, testability);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 组件销毁时，销毁关联视图以及相关的服务</span></span><br><span class="line">    compRef.onDestroy(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.detachView(compRef.hostView);</span><br><span class="line">      remove(<span class="keyword">this</span>.components, compRef);</span><br><span class="line">      <span class="keyword">if</span> (testabilityRegistry) &#123;</span><br><span class="line">        testabilityRegistry.unregisterApplication(nativeElement);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 加载组件，包括关联视图、监听变更等</span></span><br><span class="line">    <span class="keyword">this</span>._loadComponent(compRef);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> compRef;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在创建根组件的过程中，会关联 DOM 元素视图、添加对状态变更的检测机制。</p><p>根组件是一个入口组件，Angular CLI 创建的默认应用只有一个组件<code>AppComponent</code>，Angular 会在引导过程中把它加载到 DOM 中。</p><p>在根组件的创建过程中，通常会根据根组件中引用到的其他组件，触发一系列组件的创建并形成组件树。大多数应用只有一个组件树，并且只从一个根组件开始引导。</p><h3 id="创建组件过程"><a href="#创建组件过程" class="headerlink" title="创建组件过程"></a>创建组件过程</h3><p>Angular 中创建组件的过程如下（参考<a href="https://angular.cn/guide/architecture-services" target="_blank" rel="noopener">服务与依赖注入简介</a>）：</p><ol><li>当 Angular 创建组件类的新实例时，它会通过查看该组件类的构造函数，来决定该组件依赖哪些服务或其它依赖项。</li><li>当 Angular 发现某个组件依赖某个服务时，它会首先检查是否该注入器中已经有了那个服务的任何现有实例。如果所请求的服务尚不存在，注入器就会使用以前注册的服务提供者来制作一个，并把它加入注入器中，然后把该服务返回给 Angular。</li><li>当所有请求的服务已解析并返回时，Angular 可以用这些服务实例为参数，调用该组件的构造函数。</li></ol><p>Angular 会在执行应用时创建注入器，第一个注入器是根注入器，创建于引导过程中。借助注入器继承机制，可以把全应用级的服务注入到这些组件中。</p><p>到这里，Angular 分别完成了根模块、根组件和组件树的引导过程，通过编译器则可以将组件和视图渲染到页面上。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在应用程序的引导过程中，Angular 采取了以下步骤来加载我们的第一个视图：</p><ol><li>加载<code>index.html</code>。</li><li>加载 Angular、第三方库和应用程序。</li><li>加载应用程序入口点<code>Main.ts</code>。</li><li>加载根模块。</li><li>加载根组件。</li><li>加载模板。</li></ol><p>本文我们重点从根模块的引导过程开始，介绍了引导 Angular 应用程序、引导根组件、组件的创建等过程。至于组件树的创建和渲染，则可以参考<a href>编译器</a>相关的内容。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://angular.cn/guide/bootstrapping" target="_blank" rel="noopener">通过根模块启动应用</a></li><li><a href="https://angular.cn/guide/entry-components" target="_blank" rel="noopener">Angular-入口组件</a></li><li><a href="https://www.tektutorialshub.com/angular/angular-bootstrapping-application/" target="_blank" rel="noopener">Bootstrapping in Angular: How It Works Internally</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为“为大型前端项目”而设计的前端框架，Angular 其实有许多值得参考和学习的设计，本系列主要用于研究这些设计和功能的实现原理。本文主要围绕 Angular 中的最大特点——依赖注入，介绍 Angular 依赖注入在体系在应用引导过程中的的设计和实现。&lt;/p&gt;
    
    </summary>
    
      <category term="Angular源码" scheme="https://godbasin.github.io/categories/Angular%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="功能设计" scheme="https://godbasin.github.io/tags/%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Angular框架解读--多级依赖注入设计</title>
    <link href="https://godbasin.github.io/2021/07/11/angular-design-di-2-hierarchical-di/"/>
    <id>https://godbasin.github.io/2021/07/11/angular-design-di-2-hierarchical-di/</id>
    <published>2021-07-11T06:55:31.000Z</published>
    <updated>2021-07-11T07:21:17.823Z</updated>
    
    <content type="html"><![CDATA[<p>作为“为大型前端项目”而设计的前端框架，Angular 其实有许多值得参考和学习的设计，本系列主要用于研究这些设计和功能的实现原理。本文主要围绕 Angular 中的最大特点——依赖注入，介绍 Angular 中多级依赖注入的设计。</p><a id="more"></a><p>上一篇我们介绍了 Angular 中的<code>Injectot</code>注入器、<code>Provider</code>提供者，以及注入器机制。那么，在 Angular 应用中，各个组件和模块间又是怎样共享依赖的，同样的服务是否可以多次实例化呢？</p><p>组件和模块的依赖注入过程，离不开 Angular 多级依赖注入的设计，我们来看看。</p><h1 id="多级依赖注入"><a href="#多级依赖注入" class="headerlink" title="多级依赖注入"></a>多级依赖注入</h1><p><a href="https://godbasin.github.io/2021/06/27/angular-design-di-1-basic-concepts/">前面</a>我们说过，Angular 中的注入器是可继承、且分层的。</p><p>在 Angular 中，有两个注入器层次结构：</p><ul><li><code>ModuleInjector</code>模块注入器：使用<code>@NgModule()</code>或<code>@Injectable()</code>注解在此层次结构中配置<code>ModuleInjector</code></li><li><code>ElementInjector</code>元素注入器：在每个 DOM 元素上隐式创建</li></ul><p>模块注入器和元素注入器都是树状结构的，但它们的分层结构并不完全一致。</p><h2 id="模块注入器"><a href="#模块注入器" class="headerlink" title="模块注入器"></a>模块注入器</h2><p>模块注入器的分层结构，除了与应用中模块设计有关系，还有平台模块（PlatformModule）注入器与应用程序模块（AppModule）注入器的分层结构。</p><h3 id="平台模块（PlatformModule）注入器"><a href="#平台模块（PlatformModule）注入器" class="headerlink" title="平台模块（PlatformModule）注入器"></a>平台模块（PlatformModule）注入器</h3><p>在 Angular 术语中，平台是供 Angular 应用程序在其中运行的上下文。Angular 应用程序最常见的平台是 Web 浏览器，但它也可以是移动设备的操作系统或 Web 服务器。</p><p>Angular 应用在启动时，会创建一个平台层：</p><ul><li>平台是 Angular 在网页上的入口点，每个页面只有一个平台</li><li>页面上运行的每个 Angular 应用程序，所共有的服务都在平台内绑定</li></ul><p>一个 Angular 平台，主要包括创建模块实例、销毁等功能：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> PlatformRef &#123;</span><br><span class="line">  <span class="comment">// 传入注入器，作为平台注入器</span></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> _injector: Injector</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为给定的平台创建一个 @NgModule 的实例，以进行离线编译</span></span><br><span class="line">  bootstrapModuleFactory&lt;M&gt;(moduleFactory: NgModuleFactory&lt;M&gt;, options?: BootstrapOptions):</span><br><span class="line">      <span class="built_in">Promise</span>&lt;NgModuleRef&lt;M&gt;&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用给定的运行时编译器，为给定的平台创建一个 @NgModule 的实例</span></span><br><span class="line">  bootstrapModule&lt;M&gt;(</span><br><span class="line">      moduleType: Type&lt;M&gt;,</span><br><span class="line">      compilerOptions: (CompilerOptions&amp;BootstrapOptions)|</span><br><span class="line">      <span class="built_in">Array</span>&lt;CompilerOptions&amp;BootstrapOptions&gt; = []): <span class="built_in">Promise</span>&lt;NgModuleRef&lt;M&gt;&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册销毁平台时要调用的侦听器</span></span><br><span class="line">  onDestroy(callback: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span>): <span class="built_in">void</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取平台注入器</span></span><br><span class="line">  <span class="comment">// 该平台注入器是页面上每个 Angular 应用程序的父注入器，并提供单例提供程序</span></span><br><span class="line">  <span class="keyword">get</span> injector(): Injector &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 销毁页面上的当前 Angular 平台和所有 Angular 应用程序，包括销毁在平台上注册的所有模块和侦听器</span></span><br><span class="line">  destroy() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，平台在启动的时候(<code>bootstrapModuleFactory</code>方法中)，在<code>ngZone.run</code>中创建<code>ngZoneInjector</code>，以便在 Angular 区域中创建所有实例化的服务，而<code>ApplicationRef</code>（页面上运行的 Angular 应用程序）将在 Angular 区域之外创建。</p><p>在浏览器中启动时，会创建浏览器平台：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> platformBrowser: <span class="function">(<span class="params">extraProviders?: StaticProvider[]</span>) =&gt;</span> PlatformRef =</span><br><span class="line">    createPlatformFactory(platformCore, <span class="string">'browser'</span>, INTERNAL_BROWSER_PLATFORM_PROVIDERS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其中，platformCore 平台必须包含在任何其他平台中</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> platformCore = createPlatformFactory(<span class="literal">null</span>, <span class="string">'core'</span>, _CORE_PLATFORM_PROVIDERS);</span><br></pre></td></tr></table></figure><p>使用平台工厂（例如上面的<code>createPlatformFactory</code>）创建平台时，将隐式初始化页面的平台：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createPlatformFactory</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    parentPlatformFactory: ((extraProviders?: StaticProvider[]) =&gt; PlatformRef)|<span class="literal">null</span>, name: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    providers: StaticProvider[] = []</span>): (<span class="params">extraProviders?: StaticProvider[]</span>) =&gt; <span class="title">PlatformRef</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> desc = <span class="string">`Platform: <span class="subst">$&#123;name&#125;</span>`</span>;</span><br><span class="line">  <span class="keyword">const</span> marker = <span class="keyword">new</span> InjectionToken(desc); <span class="comment">// DI 令牌</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">extraProviders: StaticProvider[] = []</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> platform = getPlatform();</span><br><span class="line">    <span class="comment">// 若平台已创建，则不做处理</span></span><br><span class="line">    <span class="keyword">if</span> (!platform || platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, <span class="literal">false</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (parentPlatformFactory) &#123;</span><br><span class="line">        <span class="comment">// 若有父级平台，则直接使用父级平台，并更新相应的提供者</span></span><br><span class="line">        parentPlatformFactory(</span><br><span class="line">            providers.concat(extraProviders).concat(&#123;provide: marker, useValue: <span class="literal">true</span>&#125;));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> injectedProviders: StaticProvider[] =</span><br><span class="line">            providers.concat(extraProviders).concat(&#123;provide: marker, useValue: <span class="literal">true</span>&#125;, &#123;</span><br><span class="line">              provide: INJECTOR_SCOPE,</span><br><span class="line">              useValue: <span class="string">'platform'</span></span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="comment">// 若无父级平台，则新建注入器，并创建平台</span></span><br><span class="line">        createPlatform(Injector.create(&#123;providers: injectedProviders, name: desc&#125;));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> assertPlatform(marker);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上过程，我们知道 Angular 应用在创建平台的时候，创建平台的模块注入器<code>ModuleInjector</code>。我们从<a href>上一节</a><code>Injector</code>定义中也能看到，<code>NullInjector</code>是所有注入器的顶部：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">abstract</span> <span class="keyword">class</span> Injector &#123;</span><br><span class="line">  <span class="keyword">static</span> NULL: Injector = <span class="keyword">new</span> NullInjector();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，在平台模块注入器之上，还有<code>NullInjector()</code>。而在平台模块注入器之下，则还有应用程序模块注入器。</p><h3 id="应用程序根模块（AppModule）注入器"><a href="#应用程序根模块（AppModule）注入器" class="headerlink" title="应用程序根模块（AppModule）注入器"></a>应用程序根模块（AppModule）注入器</h3><p>每个应用程序有至少一个 Angular 模块，根模块就是用来启动此应用的模块：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NgModule</span>(&#123; providers: APPLICATION_MODULE_PROVIDERS &#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ApplicationModule &#123;</span><br><span class="line">  <span class="comment">// ApplicationRef 需要引导程序提供组件</span></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">appRef: ApplicationRef</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AppModule</code>根应用模块由<code>BrowserModule</code>重新导出，当我们使用 CLI 的<code>new</code>命令创建新应用时，它会自动包含在根<code>AppModule</code>中。应用程序根模块中，提供者关联着内置的 DI 令牌，用于为引导程序配置根注入器。</p><p>Angular 还将<code>ComponentFactoryResolver</code>添加到根模块注入器中。此解析器存储了<code>entryComponents</code>系列工厂，因此它负责动态创建组件。</p><h3 id="模块注入器层级"><a href="#模块注入器层级" class="headerlink" title="模块注入器层级"></a>模块注入器层级</h3><p>到这里，我们可以简单地梳理出模块注入器的层级关系：</p><ol><li>模块注入器树的最上层则是应用程序根模块（AppModule）注入器，称作 root。</li><li>在 root 之上还有两个注入器，一个是平台模块（PlatformModule）注入器，一个是<code>NullInjector()</code>。</li></ol><p>因此，模块注入器的分层结构如下：</p><p><img src="https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/angular-1-injectors-1.svg" alt></p><p>在我们实际的应用中，它很可能是这样的：</p><p><img src="https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/1_rjG7U4vLG_keRYoZnryxbA.png" alt></p><p>Angular DI 具有分层注入体系，这意味着下级注入器也可以创建它们自己的服务实例。</p><h2 id="元素注入器"><a href="#元素注入器" class="headerlink" title="元素注入器"></a>元素注入器</h2><p>前面说过，在 Angular 中有两个注入器层次结构，分别是模块注入器和元素注入器。</p><h3 id="元素注入器的引入"><a href="#元素注入器的引入" class="headerlink" title="元素注入器的引入"></a>元素注入器的引入</h3><p>当 Angular 中懒加载的模块开始广泛使用时，出现了一个 <a href="https://github.com/angular/angular/issues/13722" target="_blank" rel="noopener">issue</a>：依赖注入系统导致懒加载模块的实例化加倍。</p><p>在这一次修复中，引入了<a href="https://github.com/angular/angular/commit/13686bb" target="_blank" rel="noopener">新的设计</a>：<strong>注入器使用两棵并行的树，一棵用于元素，另一棵用于模块</strong>。</p><p>Angular 会为所有<code>entryComponents</code>创建宿主工厂，它们是所有其他组件的根视图。</p><p>这意味着每次我们创建动态 Angular 组件时，都会使用根数据（<code>RootData</code>）创建根视图（<code>RootView</code>）：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> ComponentFactory_ <span class="keyword">extends</span> ComponentFactory&lt;<span class="built_in">any</span>&gt;&#123;</span><br><span class="line">  create(</span><br><span class="line">      injector: Injector, projectableNodes?: <span class="built_in">any</span>[][], rootSelectorOrNode?: <span class="built_in">string</span>|<span class="built_in">any</span>,</span><br><span class="line">      ngModule?: NgModuleRef&lt;<span class="built_in">any</span>&gt;): ComponentRef&lt;<span class="built_in">any</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!ngModule) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'ngModule should be provided'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> viewDef = resolveDefinition(<span class="keyword">this</span>.viewDefFactory);</span><br><span class="line">    <span class="keyword">const</span> componentNodeIndex = viewDef.nodes[<span class="number">0</span>].element!.componentProvider!.nodeIndex;</span><br><span class="line">    <span class="comment">// 使用根数据创建根视图</span></span><br><span class="line">    <span class="keyword">const</span> view = Services.createRootView(</span><br><span class="line">        injector, projectableNodes || [], rootSelectorOrNode, viewDef, ngModule, EMPTY_CONTEXT);</span><br><span class="line">    <span class="comment">// view.nodes 的访问器</span></span><br><span class="line">    <span class="keyword">const</span> component = asProviderData(view, componentNodeIndex).instance;</span><br><span class="line">    <span class="keyword">if</span> (rootSelectorOrNode) &#123;</span><br><span class="line">      view.renderer.setAttribute(asElementData(view, <span class="number">0</span>).renderElement, <span class="string">'ng-version'</span>, VERSION.full);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建组件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ComponentRef_(view, <span class="keyword">new</span> ViewRef_(view), component);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该根数据（<code>RootData</code>）包含对<code>elInjector</code>和<code>ngModule</code>注入器的引用：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRootData</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    elInjector: Injector, ngModule: NgModuleRef&lt;<span class="built_in">any</span>&gt;, rendererFactory: RendererFactory2,</span></span></span><br><span class="line"><span class="function"><span class="params">    projectableNodes: <span class="built_in">any</span>[][], rootSelectorOrNode: <span class="built_in">any</span></span>): <span class="title">RootData</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> sanitizer = ngModule.injector.get(Sanitizer);</span><br><span class="line">  <span class="keyword">const</span> errorHandler = ngModule.injector.get(ErrorHandler);</span><br><span class="line">  <span class="keyword">const</span> renderer = rendererFactory.createRenderer(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ngModule,</span><br><span class="line">    injector: elInjector,</span><br><span class="line">    projectableNodes,</span><br><span class="line">    selectorOrNode: rootSelectorOrNode,</span><br><span class="line">    sanitizer,</span><br><span class="line">    rendererFactory,</span><br><span class="line">    renderer,</span><br><span class="line">    errorHandler,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引入元素注入器树，原因是这样的设计比较简单。通过更改注入器层次结构，避免交错插入模块和组件注入器，从而导致延迟加载模块的双倍实例化。因为每个注入器都只有一个父对象，并且每次解析都必须精确地寻找一个注入器来检索依赖项。</p><h3 id="元素注入器（Element-Injector）"><a href="#元素注入器（Element-Injector）" class="headerlink" title="元素注入器（Element Injector）"></a>元素注入器（Element Injector）</h3><p>在 Angular 中，视图是模板的表示形式，它包含不同类型的节点，其中便有元素节点，元素注入器位于此节点上：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ElementDef &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 在该视图中可见的 DI 的公共提供者</span></span><br><span class="line">  publicProviders: &#123;[tokenKey: <span class="built_in">string</span>]: NodeDef&#125;|<span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 与 visiblePublicProviders 相同，但还包括位于此元素上的私有提供者</span></span><br><span class="line">  allProviders: &#123;[tokenKey: <span class="built_in">string</span>]: NodeDef&#125;|<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下<code>ElementInjector</code>为空，除非在<code>@Directive()</code>或<code>@Component()</code>的<code>providers</code>属性中进行配置。</p><p>当 Angular 为嵌套的 HTML 元素创建元素注入器时，要么从父元素注入器继承它，要么直接将父元素注入器分配给子节点定义。</p><p>如果子 HTML 元素上的元素注入器具有提供者，则应该继承该注入器。否则，无需为子组件创建单独的注入器，并且如果需要，可以直接从父级的注入器中解决依赖项。</p><h3 id="元素注入器与模块注入器的设计"><a href="#元素注入器与模块注入器的设计" class="headerlink" title="元素注入器与模块注入器的设计"></a>元素注入器与模块注入器的设计</h3><p>那么，元素注入器与模块注入器是从哪个地方开始成为平行树的呢？</p><p>我们已经知道，应用程序根模块（<code>AppModule</code>）会在使用 CLI 的<code>new</code>命令创建新应用时，自动包含在根<code>AppModule</code>中。</p><p>当应用程序（<code>ApplicationRef</code>）启动（<code>bootstrap</code>）时，会创建<code>entryComponent</code>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compRef = componentFactory.create(Injector.NULL, [], selectorOrNode, ngModule);</span><br></pre></td></tr></table></figure><p>该过程会使用根数据（<code>RootData</code>）创建根视图（<code>RootView</code>），同时会创建根元素注入器，在这里<code>elInjector</code>为<code>Injector.NULL</code>。</p><p>在这里，Angular 的注入器树被分成元素注入器树和模块注入器树，这两个平行的树了。</p><p>Angular 会有规律的创建下级注入器，每当 Angular 创建一个在<code>@Component()</code>中指定了<code>providers</code>的组件实例时，它也会为该实例创建一个新的子注入器。类似的，当在运行期间加载一个新的<code>NgModule</code>时，Angular 也可以为它创建一个拥有自己的提供者的注入器。</p><p>子模块和组件注入器彼此独立，并且会为所提供的服务分别创建自己的实例。当 Angular 销毁<code>NgModule</code>或组件实例时，也会销毁这些注入器以及注入器中的那些服务实例。</p><h2 id="Angular-解析依赖过程"><a href="#Angular-解析依赖过程" class="headerlink" title="Angular 解析依赖过程"></a>Angular 解析依赖过程</h2><p>上面我们介绍了 Angular 中的两种注入器树：模块注入器树和元素注入器树。那么，Angular 在提供依赖时，又会以怎样的方式去进行解析呢。</p><p>在 Angular 种，当为组件/指令解析 token 获取依赖时，Angular 分为两个阶段来解析它：</p><ul><li>针对<code>ElementInjector</code>层次结构（其父级）</li><li>针对<code>ModuleInjector</code>层次结构（其父级）</li></ul><p>其过程如下（参考<a href="https://angular.cn/guide/hierarchical-dependency-injection#resolution-rules" target="_blank" rel="noopener">多级注入器-解析规则</a>）：</p><ol><li>当组件声明依赖项时，Angular 会尝试使用它自己的<code>ElementInjector</code>来满足该依赖。</li><li>如果组件的注入器缺少提供者，它将把请求传给其父组件的<code>ElementInjector</code>。</li><li>这些请求将继续转发，直到 Angular 找到可以处理该请求的注入器或用完祖先<code>ElementInjector</code>。</li><li>如果 Angular 在任何<code>ElementInjector</code>中都找不到提供者，它将返回到发起请求的元素，并在<code>ModuleInjector</code>层次结构中进行查找。</li><li>如果 Angular 仍然找不到提供者，它将引发错误。</li></ol><p>为此，Angular 引入一种特殊的合并注入器。</p><h3 id="合并注入器（Merge-Injector）"><a href="#合并注入器（Merge-Injector）" class="headerlink" title="合并注入器（Merge Injector）"></a>合并注入器（Merge Injector）</h3><p>合并注入器本身没有任何值，它只是视图和元素定义的组合。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Injector_ <span class="keyword">implements</span> Injector &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> view: ViewData, <span class="keyword">private</span> elDef: NodeDef|<span class="literal">null</span></span>) &#123;&#125;</span><br><span class="line">  <span class="keyword">get</span>(token: <span class="built_in">any</span>, notFoundValue: <span class="built_in">any</span> = Injector.THROW_IF_NOT_FOUND): <span class="built_in">any</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> allowPrivateServices =</span><br><span class="line">        <span class="keyword">this</span>.elDef ? (<span class="keyword">this</span>.elDef.flags &amp; NodeFlags.ComponentView) !== <span class="number">0</span> : <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> Services.resolveDep(</span><br><span class="line">        <span class="keyword">this</span>.view, <span class="keyword">this</span>.elDef, allowPrivateServices,</span><br><span class="line">        &#123;flags: DepFlags.None, token, tokenKey: tokenKey(token)&#125;, notFoundValue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 Angular 解析依赖项时，合并注入器则是元素注入器树和模块注入器树之间的桥梁。当 Angular 尝试解析组件或指令中的某些依赖关系时，会使用合并注入器来遍历元素注入器树，然后，如果找不到依赖关系，则切换到模块注入器树以解决依赖关系。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> ViewContainerRef_ <span class="keyword">implements</span> ViewContainerData &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 父级试图元素注入器的查询</span></span><br><span class="line">  <span class="keyword">get</span> parentInjector(): Injector &#123;</span><br><span class="line">    <span class="keyword">let</span> view = <span class="keyword">this</span>._view;</span><br><span class="line">    <span class="keyword">let</span> elDef = <span class="keyword">this</span>._elDef.parent;</span><br><span class="line">    <span class="keyword">while</span> (!elDef &amp;&amp; view) &#123;</span><br><span class="line">      elDef = viewParentEl(view);</span><br><span class="line">      view = view.parent!;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> view ? <span class="keyword">new</span> Injector_(view, elDef) : <span class="keyword">new</span> Injector_(<span class="keyword">this</span>._view, <span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h3><p>注入器是可继承的，这意味着如果指定的注入器无法解析某个依赖，它就会请求父注入器来解析它。具体的解析算法在<code>resolveDep()</code>方法中实现：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">resolveDep</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    view: ViewData, elDef: NodeDef, allowPrivateServices: <span class="built_in">boolean</span>, depDef: DepDef,</span></span></span><br><span class="line"><span class="function"><span class="params">    notFoundValue: <span class="built_in">any</span> = Injector.THROW_IF_NOT_FOUND</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//          mod1</span></span><br><span class="line">  <span class="comment">//         /</span></span><br><span class="line">  <span class="comment">//       el1   mod2</span></span><br><span class="line">  <span class="comment">//         \  /</span></span><br><span class="line">  <span class="comment">//         el2</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 请求 el2.injector.get(token)时，按以下顺序检查并返回找到的第一个值：</span></span><br><span class="line">  <span class="comment">// - el2.injector.get(token, default)</span></span><br><span class="line">  <span class="comment">// - el1.injector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) -&gt; do not check the module</span></span><br><span class="line">  <span class="comment">// - mod2.injector.get(token, default)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是<code>&lt;child&gt;&lt;/child&gt;</code>这样模板的根<code>AppComponent</code>组件，那么在 Angular 中将具有三个视图：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HostView_AppComponent --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">my-app</span>&gt;</span><span class="tag">&lt;/<span class="name">my-app</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- View_AppComponent --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- View_ChildComponent --&gt;</span></span><br><span class="line">    some content</span><br></pre></td></tr></table></figure><p>依赖解析过程，解析算法会基于视图层次结构，如图所示进行：</p><p><img src="https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/1_p3nTsvwXWjCilG5zG3ecKw.png" alt></p><p>如果在子组件中解析某些令牌，Angular 将：</p><ol><li>首先查看子元素注入器，进行检查<code>elRef.element.allProviders|publicProviders</code>。</li><li>然后遍历所有父视图元素（1），并检查元素注入器中的提供者。</li><li>如果下一个父视图元素等于<code>null</code>（2），则返回到<code>startView</code>（3），检查<code>startView.rootData.elnjector</code>（4）。</li><li>只有在找不到令牌的情况下，才检查<code>startView.rootData module.injector</code>（ 5 ）。</li></ol><p>由此可见，Angular 在遍历组件以解析某些依赖性时，将搜索特定视图的父元素而不是特定元素的父元素。视图的父元素可以通过以下方法获得：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于组件视图，这是宿主元素</span></span><br><span class="line"><span class="comment">// 对于嵌入式视图，这是包含视图容器的父节点的索引</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">viewParentEl</span>(<span class="params">view: ViewData</span>): <span class="title">NodeDef</span>|<span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> parentView = view.parent;</span><br><span class="line">  <span class="keyword">if</span> (parentView) &#123;</span><br><span class="line">    <span class="keyword">return</span> view.parentNodeDef !.parent;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了 Angular 中注入器的层级结构，在 Angular 中有两棵平行的注入器树：模块注入器树和元素注入器树。</p><p>元素注入器树的引入，主要是为了解决依赖注入解析懒加载模块时，导致模块的双倍实例化问题。在元素注入器树引入后，Angular 解析依赖的过程也有调整，优先寻找元素注入器以及父视图元素注入器等注入器的依赖，只有元素注入器中无法找到令牌时，才会查询模块注入器中的依赖。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://angular.cn/guide/hierarchical-dependency-injection" target="_blank" rel="noopener">Angular-多级注入器</a></li><li><a href="https://medium.com/angular-in-depth/angular-dependency-injection-and-tree-shakeable-tokens-4588a8f70d5d" target="_blank" rel="noopener">What you always wanted to know about Angular Dependency Injection tree</a></li><li><a href="https://indepth.dev/posts/1063/a-curious-case-of-the-host-decorator-and-element-injectors-in-angular" target="_blank" rel="noopener">A curious case of the @Host decorator and Element Injectors in Angular</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为“为大型前端项目”而设计的前端框架，Angular 其实有许多值得参考和学习的设计，本系列主要用于研究这些设计和功能的实现原理。本文主要围绕 Angular 中的最大特点——依赖注入，介绍 Angular 中多级依赖注入的设计。&lt;/p&gt;
    
    </summary>
    
      <category term="Angular源码" scheme="https://godbasin.github.io/categories/Angular%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="功能设计" scheme="https://godbasin.github.io/tags/%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Angular框架解读--依赖注入的基本概念</title>
    <link href="https://godbasin.github.io/2021/06/27/angular-design-di-1-basic-concepts/"/>
    <id>https://godbasin.github.io/2021/06/27/angular-design-di-1-basic-concepts/</id>
    <published>2021-06-27T05:55:23.000Z</published>
    <updated>2021-06-27T06:10:04.941Z</updated>
    
    <content type="html"><![CDATA[<p>作为“为大型前端项目”而设计的前端框架，Angular 其实有许多值得参考和学习的设计，本系列主要用于研究这些设计和功能的实现原理。本文主要围绕 Angular 中的最大特点——依赖注入，首先来介绍一些 Angular 依赖注入体系中的基本概念。</p><a id="more"></a><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p>既然要介绍 Angular 框架的依赖注入设计，那么先铺垫一下依赖注入的基本概念。我们常常会搞混依赖倒置原则（DIP）、控制反转（IoC）、依赖注入（DI）这几个概念，因此这里会先简单介绍一下。</p><h3 id="依赖倒置原则、控制反转、依赖注入"><a href="#依赖倒置原则、控制反转、依赖注入" class="headerlink" title="依赖倒置原则、控制反转、依赖注入"></a>依赖倒置原则、控制反转、依赖注入</h3><p>低耦合、高内聚大概是每个系统的设计目标之一，而为此产生了很多的设计模式和理念，其中便包括依赖倒置原则、控制反转的设计思想。</p><p><strong>(1) 依赖倒置原则（DIP）。</strong></p><p>依赖倒置原则的原始定义为：</p><ul><li>高层模块不应该依赖低层模块，两者都应该依赖其抽象；</li><li>抽象不应该依赖细节，细节应该依赖抽象。</li></ul><p>简单说便是：模块间不应该直接依赖对方，应该依赖一个抽象的规则（接口或者时抽象类）。</p><p><strong>(2) 控制反转（IoC）。</strong></p><p>控制反转的定义为：模块间的依赖关系从程序内部提到外部来实例化管理。即对象在被创建的时候，由一个调控系统内所有对象的外界实体控制，并将其所依赖的对象的引用传递(注入)给它。</p><p>实现控制反转主要有两种方式：</p><ul><li>依赖注入：被动的接收依赖对象</li><li>依赖查找：主动索取依赖的对象</li></ul><p><strong>(3) 依赖注入。</strong></p><p>依赖注入，是控制反转的最为常见的一种技术。</p><p>依赖倒置和控制反转两者相辅相成，常常可以一起使用，可有效地降低模块间的耦合。</p><h2 id="Angular-中的依赖注入"><a href="#Angular-中的依赖注入" class="headerlink" title="Angular 中的依赖注入"></a>Angular 中的依赖注入</h2><p>在 Angular 中，同样使用了依赖注入的技术，DI 框架会在实例化某个类时，向其提供这个类所声明的依赖项（依赖项：指当类需要执行其功能时，所需要的服务或对象）。</p><p>Angular 中的依赖注入基本上是围绕着组件或者是模块展开的，主要用于给新建的组件提供依赖。</p><p>Angular 中主要的依赖注入机制是<strong>注入器机制</strong>：</p><ul><li>应用中所需的任何依赖，都必须使用该应用的注入器来注册一个提供者，以便注入器可以使用这个提供者来创建新实例</li><li>Angular 会在启动过程中，创建全应用级注入器以及所需的其它注入器</li></ul><p>这里面主要涉及两个概念，分别是<strong>Injector 注入器</strong>和<strong>Provider 提供商</strong>，我们来看看。</p><h3 id="Injector-注入器"><a href="#Injector-注入器" class="headerlink" title="Injector 注入器"></a>Injector 注入器</h3><p>Injector 注入器用于创建依赖，会维护一个容器来管理这些依赖，并尽可能地复用它们。注入器会提供依赖的一个单例，并把这个单例对象注入到多个组件中。</p><p>显然，作为一个用来创建、管理、维护依赖的容器，注入器的功能很简单：创建依赖实例、获取依赖实例、管理依赖实例。我们也可以从抽象类<code>Injector</code>的源码中看出来：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">abstract</span> <span class="keyword">class</span> Injector &#123;</span><br><span class="line">  <span class="comment">// 找不到依赖</span></span><br><span class="line">  <span class="keyword">static</span> THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND;</span><br><span class="line">  <span class="comment">// NullInjector 是树的顶部</span></span><br><span class="line">  <span class="comment">// 如果你在树中向上走了很远，以至于要在 NullInjector 中寻找服务，那么将收到错误消息，或者对于 @Optional()，返回 null</span></span><br><span class="line">  <span class="keyword">static</span> NULL: Injector = <span class="keyword">new</span> NullInjector();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据提供的 Token 从 Injector 检索实例</span></span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">get</span>&lt;T&gt;(</span><br><span class="line">    token: Type&lt;T&gt; | AbstractType&lt;T&gt; | InjectionToken&lt;T&gt;,</span><br><span class="line">    notFoundValue?: T,</span><br><span class="line">    flags?: InjectFlags</span><br><span class="line">  ): T;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个新的 Injector 实例，该实例提供一个或多个依赖项</span></span><br><span class="line">  <span class="keyword">static</span> create(options: &#123;</span><br><span class="line">    providers: StaticProvider[];</span><br><span class="line">    parent?: Injector;</span><br><span class="line">    name?: <span class="built_in">string</span>;</span><br><span class="line">  &#125;): Injector;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ɵɵdefineInjectable 用于构造一个 InjectableDef</span></span><br><span class="line">  <span class="comment">// 它定义 DI 系统将如何构造 Token，并且在哪些 Injector 中可用</span></span><br><span class="line">  <span class="keyword">static</span> ɵprov = ɵɵdefineInjectable(&#123;</span><br><span class="line">    token: Injector,</span><br><span class="line">    providedIn: <span class="string">"any"</span> <span class="keyword">as</span> <span class="built_in">any</span>,</span><br><span class="line">    <span class="comment">// ɵɵinject 生成的指令：从当前活动的 Injector 注入 Token</span></span><br><span class="line">    factory: <span class="function"><span class="params">()</span> =&gt;</span> ɵɵinject(INJECTOR),</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> __NG_ELEMENT_ID__ = InjectorMarkers.Injector;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，我们可以将需要共享的依赖实例添加到注入器中，并通过 Token 查询和检索注入器来获取相应的依赖实例。</p><p>需要注意的是，Angular 中的注入器是分层的，因此查找依赖的过程也是向上遍历注入器树的过程。</p><p>这是因为在 Angular 中，应用是以模块的方式组织的，具体可以参考<a href="https://godbasin.github.io/2021/06/13/angular-design-module/">Angular 框架解读–模块化组织</a>篇。一般来说，页面的 DOM 是以<code>html</code>作为根节点的树状结构，以此为基础，Angular 应用中的组件和模块也是与之相伴的树状结构。</p><p>而注入器服务于组件和模块，同样是挂载与模块和组织上的树状结构。因此，Injector 也划分为模块和组件级别，可分别为组件和模块提供依赖的具体实例。注入器是可继承的，这意味着如果指定的注入器无法解析某个依赖，它就会请求父注入器来解析它，我们同样可以从上面的创建注入器代码中看到：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个新的 Injector 实例，可传入 parent 父注入器</span></span><br><span class="line"><span class="keyword">static</span> create(options: &#123;providers: StaticProvider[], parent?: Injector, name?: <span class="built_in">string</span>&#125;): Injector;</span><br></pre></td></tr></table></figure><p>在某个注入器的范围内，服务是单例的。也就是说，在指定的注入器中最多只有某个服务的最多一个实例。如果不希望在所有地方都使用该服务的同一个实例，则可以通过注册多个注入器、并按照需要关联到组件和模块中的方式，来按需共享某个服务依赖的实例。</p><p>我们可以看到创建一个新的<code>Injector</code>实例时，传入的参数包括<code>Provider</code>，这是因为<code>Injector</code>不会直接创建依赖，而是通过<code>Provider</code>来完成的。每个注入器会维护一个提供者的列表，并根据组件或其它服务的需要，用它们来提供服务的实例。</p><h3 id="Provider-提供者"><a href="#Provider-提供者" class="headerlink" title="Provider 提供者"></a>Provider 提供者</h3><p>Provider 提供者用来告诉注入器应该如何获取或创建依赖，要想让注入器能够创建服务（或提供其它类型的依赖），必须使用某个提供者配置好注入器。</p><p>一个提供者对象定义了如何获取与 DI 令牌（token） 相关联的可注入依赖，而注入器会使用这个提供者来创建它所依赖的那些类的实例。</p><blockquote><p>关于 DI 令牌：</p><ul><li>当使用提供者配置注入器时，就会把提供者和一个 DI 令牌关联起来；</li><li>注入器维护一个内部令牌-提供者的映射表，当请求一个依赖项时就会引用它，令牌就是这个映射表的键。</li></ul></blockquote><p>提供者的类型很多，从<a href="https://angular.cn/guide/dependency-injection-providers" target="_blank" rel="noopener">官方文档</a>中可以阅读它们的具体定义：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> Provider =</span><br><span class="line">  | TypeProvider</span><br><span class="line">  | ValueProvider</span><br><span class="line">  | ClassProvider</span><br><span class="line">  | ConstructorProvider</span><br><span class="line">  | ExistingProvider</span><br><span class="line">  | FactoryProvider</span><br><span class="line">  | <span class="built_in">any</span>[];</span><br></pre></td></tr></table></figure><p>提供者的解析过程如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveReflectiveFactory</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  provider: NormalizedProvider</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">ResolvedReflectiveFactory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> factoryFn: <span class="built_in">Function</span>;</span><br><span class="line">  <span class="keyword">let</span> resolvedDeps: ReflectiveDependency[];</span><br><span class="line">  <span class="keyword">if</span> (provider.useClass) &#123;</span><br><span class="line">    <span class="comment">// 使用类来提供依赖</span></span><br><span class="line">    <span class="keyword">const</span> useClass = resolveForwardRef(provider.useClass);</span><br><span class="line">    factoryFn = reflector.factory(useClass);</span><br><span class="line">    resolvedDeps = _dependenciesFor(useClass);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (provider.useExisting) &#123;</span><br><span class="line">    <span class="comment">// 使用已有依赖</span></span><br><span class="line">    factoryFn = <span class="function">(<span class="params">aliasInstance: <span class="built_in">any</span></span>) =&gt;</span> aliasInstance;</span><br><span class="line">    <span class="comment">// 从根据 token 获取具体的依赖</span></span><br><span class="line">    resolvedDeps = [</span><br><span class="line">      ReflectiveDependency.fromKey(ReflectiveKey.get(provider.useExisting)),</span><br><span class="line">    ];</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (provider.useFactory) &#123;</span><br><span class="line">    <span class="comment">// 使用工厂方法提供依赖</span></span><br><span class="line">    factoryFn = provider.useFactory;</span><br><span class="line">    resolvedDeps = constructDependencies(provider.useFactory, provider.deps);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 使用提供者具体的值作为依赖</span></span><br><span class="line">    factoryFn = <span class="function"><span class="params">()</span> =&gt;</span> provider.useValue;</span><br><span class="line">    resolvedDeps = _EMPTY_LIST;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ResolvedReflectiveFactory(factoryFn, resolvedDeps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据不同类型的提供者，通过解析之后，得到由注入器 Injector 使用的提供者的内部解析表示形式：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ResolvedReflectiveProvider &#123;</span><br><span class="line">  <span class="comment">// 键，包括系统范围内的唯一 id，以及一个 token</span></span><br><span class="line">  key: ReflectiveKey;</span><br><span class="line">  <span class="comment">// 可以返回由键表示的对象的实例的工厂函数</span></span><br><span class="line">  resolvedFactories: ResolvedReflectiveFactory[];</span><br><span class="line">  <span class="comment">// 指示提供者是多提供者，还是常规提供者</span></span><br><span class="line">  multiProvider: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提供者可以是服务类<code>ClassProvider</code>本身，如果把服务类指定为提供者令牌，那么注入器的默认行为是用<code>new</code>来实例化那个类。</p><h3 id="Angular-中的依赖注入服务"><a href="#Angular-中的依赖注入服务" class="headerlink" title="Angular 中的依赖注入服务"></a>Angular 中的依赖注入服务</h3><p>在 Angular 中，服务就是一个带有<code>@Injectable</code>装饰器的类，它封装了可以在应用程序中复用的非 UI 逻辑和代码。Angular 把组件和服务分开，是为了增进模块化程度和可复用性。</p><p>用<code>@Injectable</code>标记一个类，以确保编译器将在注入类时生成必要的<a href="https://godbasin.github.io/2021/03/27/angular-design-metadata/">元数据</a>（元数据在 Angular 中也是很重要的一部分），以创建类的依赖项。</p><p><code>@Injectable</code>装饰器的类会在编译之后，得到 Angular 可注入对象：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据其 Injectable 元数据，编译 Angular 可注入对象，并对结果进行修补</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">compileInjectable</span>(<span class="params"><span class="keyword">type</span>: Type&lt;<span class="built_in">any</span>&gt;, srcMeta?: Injectable</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 该编译过程依赖 @angular/compiler</span></span><br><span class="line">  <span class="comment">// 可参考编译器中的 compileFactoryFunction compileInjectable 实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Angular 中可注入对象（<code>InjectableDef</code>）定义 DI 系统将如何构造 token 令牌，以及在哪些注入器（如果有）中可用：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ɵɵInjectableDef&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// 指定给定类型属于特定注入器，包括 root/platform/any/null 以及特定的 NgModule</span></span><br><span class="line">  providedIn: InjectorType&lt;<span class="built_in">any</span>&gt; | <span class="string">"root"</span> | <span class="string">"platform"</span> | <span class="string">"any"</span> | <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 此定义所属的令牌</span></span><br><span class="line">  token: unknown;</span><br><span class="line">  <span class="comment">// 要执行以创建可注入实例的工厂方法</span></span><br><span class="line">  factory: <span class="function">(<span class="params">t?: Type&lt;<span class="built_in">any</span>&gt;</span>) =&gt;</span> T;</span><br><span class="line">  <span class="comment">// 在没有显式注入器的情况下，存储可注入实例的位置</span></span><br><span class="line">  value: T | <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>@Injectable()</code>的<code>providedIn</code>时，优化工具可以进行 Tree-shaking 优化，从而删除应用程序中未使用的服务，以减小捆绑包尺寸。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文简单介绍了在 Angular 依赖注入体系中比较关键的几个概念，主要包括<code>Injector</code>、<code>Provider</code>和<code>Injectable</code>。</p><p>对于注入器、提供者和可注入服务，我们可以简单地这样理解：</p><ol><li>注入器用于创建依赖，会维护一个容器来管理这些依赖，并尽可能地复用它们。</li><li>一个注入器中的依赖服务，只有一个实例。</li><li>注入器需要使用提供者来管理依赖，并通过 token（DI 令牌）来进行关联。</li><li>提供者用于高速注入器应该如何获取或创建依赖。</li><li>可注入服务类会根据元数据编译后，得到可注入对象，该对象可用于创建实例。</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://angular.cn/guide/dependency-injection" target="_blank" rel="noopener">Angular-Angular 中的依赖注入</a></li><li><a href="https://angular.cn/guide/dependency-injection-providers" target="_blank" rel="noopener">Angular-依赖提供者</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为“为大型前端项目”而设计的前端框架，Angular 其实有许多值得参考和学习的设计，本系列主要用于研究这些设计和功能的实现原理。本文主要围绕 Angular 中的最大特点——依赖注入，首先来介绍一些 Angular 依赖注入体系中的基本概念。&lt;/p&gt;
    
    </summary>
    
      <category term="Angular源码" scheme="https://godbasin.github.io/categories/Angular%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="功能设计" scheme="https://godbasin.github.io/tags/%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Angular框架解读--模块化组织</title>
    <link href="https://godbasin.github.io/2021/06/13/angular-design-module/"/>
    <id>https://godbasin.github.io/2021/06/13/angular-design-module/</id>
    <published>2021-06-13T07:33:33.000Z</published>
    <updated>2021-06-13T07:42:06.616Z</updated>
    
    <content type="html"><![CDATA[<p>作为“为大型前端项目”而设计的前端框架，Angular 其实有许多值得参考和学习的设计，本系列主要用于研究这些设计和功能的实现原理。本文主要围绕 Angular 中的模块设计、模块化组织等内容进行介绍。</p><a id="more"></a><h2 id="Angular-中的模块"><a href="#Angular-中的模块" class="headerlink" title="Angular 中的模块"></a>Angular 中的模块</h2><p>在 AngularJS 升级到 Angular（2+ 版本）之后，引入了模块的设计。在我们进行 Angular 应用开发时，总是离不开模块，包括 Angular 自带的通用模块，以及应用启动的根模块等等。</p><p>说到模块化，前端开发首先会想到 <a href="https://hacks.mozilla.org/2015/08/es6-in-depth-modules/" target="_blank" rel="noopener">ES6 的模块</a>，这两者其实并没有什么关联：</p><ul><li>ES6 模块以文件为单位；Angular 模块则是以 NgModule 为单位。</li><li>ES6 模块用于跨文件的功能调用；Angular 模块用于组织有特定意义的功能块。</li><li>ES6 模块在编译阶段确认各个模块的依赖关系，模块间关系扁平；Angular 模块则可以带有深度的层次结构。</li></ul><h3 id="NgModules-定义"><a href="#NgModules-定义" class="headerlink" title="NgModules 定义"></a>NgModules 定义</h3><p>在 Angular 中，会使用 NgModules 来进行模块组织和管理。</p><p>NgModule 是一个带有<code>@NgModule</code>装饰器的类，<code>@NgModule</code>的参数是一个元数据对象，用于描述如何编译组件的模板，以及如何在运行时创建注入器。 它会标出该模块自己的组件、指令和管道，通过<code>exports</code>属性公开其中的一部分，以便外部组件使用它们。 关于元数据和装饰器，可参考<a href="https://godbasin.github.io/2021/03/27/angular-design-metadata/">Angular框架解读–元数据和装饰器</a>一节。</p><p>NgModule 把组件、指令和管道打包成内聚的功能块，每个模块聚焦于一个特性区域、业务领域、工作流或通用工具。运行时，模块相关的信息存储在<code>NgModuleDef</code>中：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NgModuleDef 是运行时用于组装组件、指令、管道和注入器的内部数据结构</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> NgModuleDef&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// 表示模块的令牌，由DI使用</span></span><br><span class="line">  <span class="keyword">type</span>: T;</span><br><span class="line">  <span class="comment">// 要引导的组件列表</span></span><br><span class="line">  bootstrap: Type&lt;<span class="built_in">any</span>&gt;[]|<span class="function">(<span class="params">(<span class="params"></span>) =&gt; Type&lt;<span class="built_in">any</span>&gt;[]</span>);</span></span><br><span class="line"><span class="function">  // 此模块声明的组件、指令和管道的列表</span></span><br><span class="line"><span class="function">  <span class="params">declarations</span>: <span class="params">Type</span>&lt;<span class="params">any</span>&gt;[]|(<span class="params">(<span class="params"></span>) =&gt; Type&lt;<span class="built_in">any</span>&gt;[]</span>);</span></span><br><span class="line"><span class="function">  // 此模块导入的模块列表或 <span class="params">ModuleWithProviders</span> </span></span><br><span class="line"><span class="function">  <span class="params">imports</span>: <span class="params">Type</span>&lt;<span class="params">any</span>&gt;[]|(<span class="params">(<span class="params"></span>) =&gt; Type&lt;<span class="built_in">any</span>&gt;[]</span>);</span></span><br><span class="line"><span class="function">  // 该模块导出的模块、<span class="params">ModuleWithProviders</span>、组件、指令或管道的列表</span></span><br><span class="line"><span class="function">  <span class="params">exports</span>: <span class="params">Type</span>&lt;<span class="params">any</span>&gt;[]|(<span class="params">(<span class="params"></span>) =&gt; Type&lt;<span class="built_in">any</span>&gt;[]</span>);</span></span><br><span class="line"><span class="function">  // 为该模块计算的 <span class="params">transitiveCompileScopes</span> 的缓存值</span></span><br><span class="line"><span class="function">  <span class="params">transitiveCompileScopes</span>: <span class="params">NgModuleTransitiveScopes</span>|<span class="params">null</span>;</span></span><br><span class="line"><span class="function">  // 声明 <span class="params">NgModule</span> 中允许的元素的一组模式</span></span><br><span class="line"><span class="function">  <span class="params">schemas</span>: <span class="params">SchemaMetadata</span>[]|<span class="params">null</span>;</span></span><br><span class="line"><span class="function">  // 应为其注册模块的唯一<span class="params">ID</span></span></span><br><span class="line"><span class="function">  <span class="params">id</span>: <span class="params">string</span>|<span class="params">null</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>宏观来讲，NgModule 是组织 Angular 应用的一种方式，它们通过<code>@NgModule</code>装饰器中的元数据来实现这一点，这些元数据可以分成三类：</p><ul><li>静态的：编译器配置，通过<code>declarations</code>数组来配置。用于告诉编译器指令的选择器，并通过选择器匹配的方式，决定要把该指令应用到模板中的什么位置</li><li>运行时：通过<code>providers</code>数组提供给注入器的配置</li><li>组合/分组：通过<code>imports</code>和<code>exports</code>数组来把多个 NgModule 放在一起，并让它们可用</li></ul><p>可以看到，一个 NgModules 模块通过<code>declarations</code>声明该模块的组件、指令和管道，同时通过<code>import</code>导入其他模块和服务，以此来构成内聚的功能块。NgModule 还能把一些服务提供者添加到应用的依赖注入器中，具体可参考后续依赖注入部分内容。</p><h3 id="模块化组织"><a href="#模块化组织" class="headerlink" title="模块化组织"></a>模块化组织</h3><p>每个 Angular 应用有至少一个模块，该模块称为根模块（AppModule）。Angular 应用的启动，便是由根模块开始的，可以参考后续的依赖注入的引导过程内容。</p><p>对于一个简单的 Angular 应用来说，一个根模块就足以管理整个应用的功能。对于复杂的应用来说，则可以根据功能来划分成不同的模块，每个模块可专注于某项功能或业务领域、工作流程或导航流程、通用工具集，或者成为一个或多个服务提供者。</p><p>在 Angular 中，推荐的模块可以根据类型划分为：</p><ul><li>领域模块：领域模块围绕特性、业务领域或用户体验进行组织</li><li>带路由的模块：模块的顶层组件充当路由器访问这部分路由时的目的地</li><li>路由配置模块：路由配置模块为另一个模块提供路由配置</li><li>服务模块：服务模块提供实用服务，比如数据访问和消息传递</li><li>小部件：小部件模块可以为其它模块提供某些组件、指令或管道</li><li>共享模块：共享模块可以为其它的模块提供组件，指令和管道的集合</li></ul><p>可见，模块可以以不同的方式进行组织，可以包括组件、指令和管道和服务，也可以仅提供其中一种，比如<code>HttpClientModule</code>便是仅由提供者组织的模块：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  <span class="comment">// XSRF 保护的可选配置</span></span><br><span class="line">  imports: [</span><br><span class="line">    HttpClientXsrfModule.withOptions(&#123;</span><br><span class="line">      cookieName: <span class="string">'XSRF-TOKEN'</span>,</span><br><span class="line">      headerName: <span class="string">'X-XSRF-TOKEN'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// 配置 DI，并在其中将其与 HTTP 通信的支持服务一起导入</span></span><br><span class="line">  providers: [</span><br><span class="line">    HttpClient,</span><br><span class="line">    &#123;provide: HttpHandler, useClass: HttpInterceptingHandler&#125;,</span><br><span class="line">    HttpXhrBackend,</span><br><span class="line">    &#123;provide: HttpBackend, useExisting: HttpXhrBackend&#125;,</span><br><span class="line">    BrowserXhr,</span><br><span class="line">    &#123;provide: XhrFactory, useExisting: BrowserXhr&#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> HttpClientModule &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模块能力"><a href="#模块能力" class="headerlink" title="模块能力"></a>模块能力</h2><p>现在我们已经知道，NgModule 是把组件、指令和管道打包成内聚的功能块，那么在 NgModule 里面是怎么管理这些内容的呢？</p><h3 id="模块与组件"><a href="#模块与组件" class="headerlink" title="模块与组件"></a>模块与组件</h3><p>在 Angular 中，每个组件都应该（且只能）声明（declare）在一个 NgModule 类中。属于相同 NgModule 的组件会共享同一个编译上下文环境，该环境信息由<code>LocalModuleScopeRegistry</code>维护：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> LocalModuleScopeRegistry <span class="keyword">implements</span> MetadataRegistry, ComponentScopeReader &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 从当前编译单元到声明它们的 NgModule 的组件映射</span></span><br><span class="line">  <span class="keyword">private</span> declarationToModule = <span class="keyword">new</span> Map&lt;ClassDeclaration, DeclarationData&gt;();</span><br><span class="line">  <span class="comment">// 这从指令/管道类映射到声明该指令/管道的每个 NgModule 的数据映射</span></span><br><span class="line">  <span class="keyword">private</span> duplicateDeclarations =</span><br><span class="line">      <span class="keyword">new</span> Map&lt;ClassDeclaration, Map&lt;ClassDeclaration, DeclarationData&gt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> moduleToRef = <span class="keyword">new</span> Map&lt;ClassDeclaration, Reference&lt;ClassDeclaration&gt;&gt;();</span><br><span class="line">  <span class="comment">// 为当前程序中声明的每个 NgModule 计算的 LocalModuleScope 的缓存</span></span><br><span class="line">  <span class="keyword">private</span> cache = <span class="keyword">new</span> Map&lt;ClassDeclaration, LocalModuleScope|<span class="literal">null</span>&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将 NgModule 的数据添加到注册表中</span></span><br><span class="line">  registerNgModuleMetadata(data: NgModuleMeta): <span class="built_in">void</span> &#123;&#125;</span><br><span class="line">  <span class="comment">// 为组件获取作用域</span></span><br><span class="line">  getScopeForComponent(clazz: ClassDeclaration): LocalModuleScope|<span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> scope = !<span class="keyword">this</span>.declarationToModule.has(clazz) ?</span><br><span class="line">        <span class="literal">null</span> :</span><br><span class="line">        <span class="comment">// 返回 NgModule 的作用域</span></span><br><span class="line">        <span class="keyword">this</span>.getScopeOfModule(<span class="keyword">this</span>.declarationToModule.get(clazz)!.ngModule);</span><br><span class="line">    <span class="keyword">return</span> scope;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 收集模块及其指令/管道的注册数据，并将其转换为完整的 LocalModuleScope</span></span><br><span class="line">  getScopeOfModule(clazz: ClassDeclaration): LocalModuleScope|<span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.moduleToRef.has(clazz) ?</span><br><span class="line">        <span class="keyword">this</span>.getScopeOfModuleReference(<span class="keyword">this</span>.moduleToRef.get(clazz)!) :</span><br><span class="line">        <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>LocalModuleScopeRegistry</code>类实现 NgModule 声明、导入和导出的逻辑，并且可以为给定组件生成在该组件的模板中“可见”的一组指令和管道。它收集有关本地的 NgModules，指令、组件和管道的信息，并且可以生成<code>LocalModuleScope</code>，概括了组件的编译范围。</p><p>每个 NgModule 在编译<code>@NgModule</code>装饰器的元数据时，会向<code>LocalModuleScopeRegistry</code>注册该模块的信息：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> NgModuleDecoratorHandler <span class="keyword">implements</span></span><br><span class="line">    DecoratorHandler&lt;Decorator, NgModuleAnalysis, NgModuleResolution&gt; &#123;</span><br><span class="line">  register(node: ClassDeclaration, analysis: NgModuleAnalysis): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="comment">// 这样可以确保在 compile() 阶段，模块的元数据可用于选择器作用域计算</span></span><br><span class="line">    <span class="keyword">this</span>.metaRegistry.registerNgModuleMetadata(&#123;</span><br><span class="line">      ref: <span class="keyword">new</span> Reference(node),</span><br><span class="line">      schemas: analysis.schemas,</span><br><span class="line">      declarations: analysis.declarations,</span><br><span class="line">      imports: analysis.imports,</span><br><span class="line">      exports: analysis.exports,</span><br><span class="line">      rawDeclarations: analysis.rawDeclarations,</span><br><span class="line">    &#125;);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>当组件在编译<code>@Component</code>装饰器的元数据时，会检查该组件是否已在 NgModule 中注册。如果已在某个模块中注册，则向<code>LocalModuleScopeRegistry</code>获取模块的编译范围，在该模块的编译范围内对其进行编译：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ComponentDecoratorHandler <span class="keyword">implements</span></span><br><span class="line">    DecoratorHandler&lt;Decorator, ComponentAnalysisData, ComponentResolutionData&gt; &#123;</span><br><span class="line">  resolve(node: ClassDeclaration, analysis: Readonly&lt;ComponentAnalysisData&gt;):</span><br><span class="line">      ResolveResult&lt;ComponentResolutionData&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 获取模块的作用域</span></span><br><span class="line">    <span class="keyword">const</span> scope = <span class="keyword">this</span>.scopeReader.getScopeForComponent(node);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (scope !== <span class="literal">null</span> &amp;&amp; (!scope.compilation.isPoisoned || <span class="keyword">this</span>.usePoisonedData)) &#123;</span><br><span class="line">      <span class="comment">// 对模块的作用域中的信息进行处理</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> dir of scope.compilation.directives) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dir.selector !== <span class="literal">null</span>) &#123;</span><br><span class="line">          matcher.addSelectables(CssSelector.parse(dir.selector), dir <span class="keyword">as</span> MatchedDirective);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> pipes = <span class="keyword">new</span> Map&lt;<span class="built_in">string</span>, Reference&lt;ClassDeclaration&gt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> pipe of scope.compilation.pipes) &#123;</span><br><span class="line">        pipes.set(pipe.name, pipe.ref);</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在获取到作用域之后，接下来组件会使用<code>R3TargetBinder</code>绑定组件模板 AST，这些内容会在 Ivy 编译器部分进行更多的介绍。</p><p>默认情况下，NgModule 都是急性加载的，也就是说它会在应用加载时尽快加载，所有模块都是如此，无论是否立即要用。对于带有很多路由的大型应用，考虑使用惰性加载：一种按需加载 NgModule 的模式。惰性加载可以减小初始包的尺寸，从而减少加载时间。</p><p>要惰性加载 Angular 模块，则需要用到<code>AppRoutingModule</code>，同时惰性加载还支持预加载的能力。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在 Angular 中，使用模块是最佳的组织方式。模块提供了聚焦于特定应用需求的一组功能，可以把应用划分成一些聚焦的功能区，比如用户工作流、路由或表单。 </p><p>对于 NgModule 模块，可以通过模块提供的服务以及共享出的组件、指令和管道来与根模块和其它 NgModule 模块进行合作。通过设置模块的导入和导出，Angular 可以解析出各个模块间的依赖关系。Angular 模块之间不允许出现循环依赖，因此一个 Angular 应用中的模块最终是呈现为以根模块为根节点的树状结构的。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://angular.cn/guide/ngmodules" target="_blank" rel="noopener">Angular-NgModules</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为“为大型前端项目”而设计的前端框架，Angular 其实有许多值得参考和学习的设计，本系列主要用于研究这些设计和功能的实现原理。本文主要围绕 Angular 中的模块设计、模块化组织等内容进行介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="Angular源码" scheme="https://godbasin.github.io/categories/Angular%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="功能设计" scheme="https://godbasin.github.io/tags/%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
</feed>
